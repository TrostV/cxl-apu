//Backend.SLICC.ModularSLICC.msg.GenMsgEnum
enumeration(CoherenceMessageType, desc="Types of coherence messages") {
  BIConflictAckL2, desc="BIConflictAckL2";
  BIConflictL2, desc="BIConflictL2";
  BIConflictL2load, desc="BIConflictL2load";
  BIRspIL2, desc="BIRspIL2";
  BIRspSL2, desc="BIRspSL2";
  BISnpDataL2, desc="BISnpDataL2";
  BISnpInvL2, desc="BISnpInvL2";
  CmpL2, desc="CmpL2";
  Cmp_EL2, desc="Cmp_EL2";
  Cmp_SL2, desc="Cmp_SL2";
  Fwd_GetML1, desc="Fwd_GetML1";
  Fwd_GetSL1, desc="Fwd_GetSL1";
  GetF_AckL1, desc="GetF_AckL1";
  GetF_Ack_ADL1, desc="GetF_Ack_ADL1";
  GetML1, desc="GetML1";
  GetML1store, desc="GetML1store";
  GetM_Ack_ADL1, desc="GetM_Ack_ADL1";
  GetM_Ack_DL1, desc="GetM_Ack_DL1";
  GetSL1, desc="GetSL1";
  GetSL1load, desc="GetSL1load";
  GetSL1store, desc="GetSL1store";
  GetS_AckL1, desc="GetS_AckL1";
  InvL1, desc="InvL1";
  Inv_AckL1, desc="Inv_AckL1";
  MemClnEvct_IL2, desc="MemClnEvct_IL2";
  MemDataL2, desc="MemDataL2";
  MemInv_A_SnpInvL2, desc="MemInv_A_SnpInvL2";
  MemInv_A_SnpInvL2load, desc="MemInv_A_SnpInvL2load";
  MemRd_A_SnpInvL2, desc="MemRd_A_SnpInvL2";
  MemRd_A_SnpInvL2load, desc="MemRd_A_SnpInvL2load";
  MemRd_S_SnpDataL2, desc="MemRd_S_SnpDataL2";
  MemRd_S_SnpDataL2load, desc="MemRd_S_SnpDataL2load";
  MemWr_IL2, desc="MemWr_IL2";
  MemWr_SL2, desc="MemWr_SL2";
  PutEL1, desc="PutEL1";
  PutE_AckL1, desc="PutE_AckL1";
  PutFL1, desc="PutFL1";
  PutF_AckL1, desc="PutF_AckL1";
  PutIL1, desc="PutIL1";
  PutI_AckL1, desc="PutI_AckL1";
  PutML1, desc="PutML1";
  PutM_AckL1, desc="PutM_AckL1";
  PutOL1, desc="PutOL1";
  PutO_AckL1, desc="PutO_AckL1";
  PutSL1, desc="PutSL1";
  PutS_AckL1, desc="PutS_AckL1";
  UnblockL1, desc="UnblockL1";
  UnblockL1store, desc="UnblockL1store";
  WBL1, desc="WBL1";

  // Added
  MemRd_SnpCur, desc="MemRd_SnpCur";
}

// Copied from MOESI_AMD_Base-msg.sm for GPU VIPER 
enumeration(CoherenceState, default="CoherenceState_NA", desc="Coherence State") {
  Modified,             desc="Modified";
  Owned,                desc="Owned state";
  Exclusive,            desc="Exclusive";
  Shared,               desc="Shared";
  NA,                   desc="NA";
}

enumeration(ProbeRequestType, desc="Probe Request Types") {
  PrbDowngrade,    desc="Probe for Status";  // EtoS, MtoO, StoS
  PrbInv,       desc="Probe to Invalidate";

  // For regions
  PrbRepl,      desc="Force the cache to do a replacement";
  PrbRegDowngrade, desc="Probe for Status";  // EtoS, MtoO, StoS
  PrbAtomic,    desc="Forwarded Atomic Operation";
}
enumeration(CoherenceResponseType, desc="Coherence Response Types") {
  NBSysResp,       desc="Northbridge response to CPU Rd request";
  NBSysWBAck,      desc="Northbridge response ok to WB";
  TDSysResp,       desc="TCCdirectory response to CPU Rd request";
  TDSysWBAck,      desc="TCCdirectory response ok to WB";
  TDSysWBNack,     desc="TCCdirectory response ok to drop";
  CPUPrbResp,      desc="CPU Probe Response";
  CPUData,         desc="CPU Data";
  StaleNotif,      desc="Notification of Stale WBAck, No data to writeback";
  CPUCancelWB,     desc="want to cancel WB to Memory";
  MemData,         desc="Data from Memory";
  InvL2Resp,       desc="Invalidate L2 response";

  // for regions
  PrivateAck,      desc="Ack that r-buf received private notify";
  RegionWbAck,     desc="Writeback Ack that r-buf completed deallocation";
  DirReadyAck,     desc="Directory (mem ctrl)<->region dir handshake";
}
enumeration(CoherenceRequestType, desc="Coherence Request Types") {
  // CPU Request Types ONLY
  RdBlk,        desc="Read Blk";
  RdBlkM,       desc="Read Blk Modified";
  RdBlkS,       desc="Read Blk Shared";
  CtoD,         desc="Change To Dirty";
  VicClean,     desc="L2 clean eviction";
  VicDirty,     desc="L2 dirty eviction";
  Atomic,       desc="Upper level atomic";
  AtomicReturn, desc="Upper level atomic";
  AtomicNoReturn, desc="Upper level atomic";
  AtomicWriteBack, desc="Upper level atomic";
  WriteThrough, desc="Ordered WriteThrough w/Data";
  WriteThroughFifo, desc="WriteThrough with no data";
  WriteThroughDummy, desc="WriteThrough with no data for atomic operation";
  WriteFlush,   desc="Release Flush";
  InvCache,     desc="Invalidate Cache";

  WrCancel,     desc="want to cancel WB to Memory"; // should this be here?

  WBApproval,   desc="WB Approval";

  // Messages between Dir and R-Dir
  ForceInv,     desc="Send invalide to the block";
  ForceDowngrade, desc="Send downgrade to the block";
  Unblock,      desc="Used to let the dir know a message has been sunk";

  // Messages between R-Dir and R-Buffer
  PrivateNotify, desc="Let region buffer know it has private access";
  SharedNotify,  desc="Let region buffer know it has shared access";
  WbNotify,      desc="Let region buffer know it saw its wb request";
  Downgrade,     desc="Force the region buffer to downgrade to shared";
  // Response to R-Dir (probably should be on a different network, but
  // I need it to be ordered with respect to requests)
  InvAck,       desc="Let the R-Dir know when the inv has occured";

  PrivateRequest, desc="R-buf wants the region in private";
  UpgradeRequest, desc="R-buf wants the region in private";
  SharedRequest,  desc="R-buf wants the region in shared (could respond with private)";
  CleanWbRequest, desc="R-buf wants to deallocate clean region";

  NA,             desc="So we don't get segfaults";
}
structure(ResponseMsg, desc="...", interface="Message") {
  Addr addr,             desc="Physical address for this request";
  CoherenceResponseType Type,  desc="NB Sys Resp or CPU Response to Probe";
  MachineID Sender,               desc="Node who sent the data";
  NetDest Destination,             desc="Node to whom the data is sent";
  // Begin Used Only By CPU Response
  DataBlock DataBlk,           desc="data for the cache line";
  bool Hit,                    desc="probe hit valid line";
  bool Shared,                 desc="True if S, or if NB Probe ReturnData==1 && O";
  bool Dirty,                  desc="Is the data dirty (different than memory)?";
  bool Ntsl,                   desc="indicates probed lin will be invalid after probe";
  bool UntransferredOwner,     desc="pending confirmation of ownership change";
  // End Used Only By CPU Response

  // Begin NB Response Only
  CoherenceState State, default=CoherenceState_NA,        desc="What returned data from NB should be in";
  bool CtoD,                    desc="was the originator a CtoD?";
  // End NB Response Only

  // Normally if a block gets hit by a probe while waiting to be written back,
  // you flip the NbReqShared signal (part of the CPURequest signal group).
  // But since this is in packets and I don't want to send a separate packet,
  // let's just send this signal back with the data instead
  bool NbReqShared,             desc="modification of Shared field from initial request, e.g. hit by shared probe";

  MessageSizeType MessageSize, desc="size category of the message";
  Cycles InitialRequestTime, desc="time the initial requests was sent from the L1Cache";
  Cycles ForwardRequestTime, desc="time the dir forwarded the request";
  Cycles ProbeRequestStartTime, desc="the time the dir started the probe request";
  bool DemandRequest, default="false", desc="For profiling purposes";

  bool L3Hit, default="false", desc="Did memory or L3 supply the data?";
  MachineID OriginalResponder, desc="Mach which wrote the data to the L3";
  MachineID CURequestor,             desc="Node who started the access";

  bool NotCached, default="false", desc="True when the Region buffer has already evicted the line";

  bool NoAckNeeded, default="false", desc="For short circuting acks";
  bool isValid, default="false", desc="Is acked block valid";
  int wfid, default="0", desc="wavefront id";
  uint64_t instSeqNum,    desc="instruction sequence number";
  int Phase,                   desc="Synchronization Phase";

  int ProgramCounter,       desc="PC that issues this request";
  bool mispred,              desc="tell TCP if the block should not be bypassed";

  bool isGLCSet, default="false", desc="GLC flag value in the request that triggered response";
  bool isSLCSet, default="false", desc="SLC flag value in the request that triggered response";


  bool functionalRead(Packet *pkt) {
    // Only PUTX messages contains the data block
    if (Type == CoherenceResponseType:CPUData ||
        Type == CoherenceResponseType:MemData) {
        return testAndRead(addr, DataBlk, pkt);
    }

    return false;
  }

  bool functionalWrite(Packet *pkt) {
    // No check on message type required since the protocol should
    // read data from those messages that contain the block
    return testAndWrite(addr, DataBlk, pkt);
  }
}
structure(CPURequestMsg, desc="...", interface="Message") {
  Addr addr,             desc="Physical address for this request";
  Addr DemandAddress,       desc="Physical block address for this request";
  CoherenceRequestType Type,   desc="Type of request";
  DataBlock DataBlk,           desc="data for the cache line";  // only for WB
  bool Dirty,                   desc="whether WB data is dirty";  // only for WB
  MachineID Requestor,            desc="Node who initiated the request";
  NetDest Destination,             desc="Multicast destination mask";
  bool Shared,                  desc="For CPU_WrVicBlk, vic is O not M.  For CPU_ClVicBlk, vic is S";
  MessageSizeType MessageSize, desc="size category of the message";
  Cycles InitialRequestTime, desc="time the initial requests was sent from the L1Cache";
  Cycles ForwardRequestTime, desc="time the dir forwarded the request";
  Cycles ProbeRequestStartTime, desc="the time the dir started the probe request";
  bool DemandRequest, default="false", desc="For profiling purposes";

  NetDest Sharers,              desc="Caches that may have a valid copy of the data";
  bool ForceShared,             desc="R-dir knows it is shared, pass on so it sends an S copy, not E";
  bool Private, default="false", desc="Requestor already has private permissions, no need for dir check";
  bool CtoDSinked, default="false", desc="This is true if the CtoD previously sent must have been sunk";

  bool NoAckNeeded, default="false", desc="True if region buffer doesn't need to ack";
  int Acks, default="0", desc="Acks that the dir (mem ctrl) should expect to receive";
  CoherenceRequestType OriginalType, default="CoherenceRequestType_NA",  desc="Type of request from core fwded through region buffer";
  WriteMask writeMask, desc="Write Through Data";
  MachineID CURequestor,            desc="Node who initiated the request";
  int wfid,                         default="0", desc="wavefront id";
  uint64_t instSeqNum,              desc="instruction sequence number";
  bool NoWriteConflict,             default="true", desc="write collided with CAB entry";
  int ProgramCounter,               desc="PC that accesses to this block";

  bool isGLCSet, default="false",   desc="GLC flag value in the request";
  bool isSLCSet, default="false",   desc="SLC flag value in the request";

  bool functionalRead(Packet *pkt) {
    // Only PUTX messages contains the data block
    if (Type == CoherenceRequestType:VicDirty) {
        return testAndRead(addr, DataBlk, pkt);
    }

    return false;
  }

  bool functionalWrite(Packet *pkt) {
    // No check on message type required since the protocol should
    // read data from those messages that contain the block
    return testAndWrite(addr, DataBlk, pkt);
  }
}
structure(NBProbeRequestMsg, desc="...", interface="Message") {
  Addr addr,              desc="Physical address for this request";
  ProbeRequestType Type,             desc="NB_PrbNxtState signal";
  bool ReturnData,              desc="Indicates CPU should return data";
  NetDest Destination,             desc="Node to whom the data is sent";
  MessageSizeType MessageSize, desc="size category of the message";
  bool DemandRequest, default="false", desc="demand request, requesting 3-hop transfer";
  Addr DemandAddress,        desc="Demand block address for a region request";
  MachineID Requestor,          desc="Requestor id for 3-hop requests";
  bool NoAckNeeded, default="false", desc="For short circuting acks";
  int ProgramCounter,           desc="PC that accesses to this block";
  bool isGLCSet, default="false", desc="GLC flag value in the request";
  bool isSLCSet, default="false", desc="SLC flag value in the request";

  bool functionalRead(Packet *pkt) {
    return false;
  }

  bool functionalWrite(Packet *pkt) {
    // No check on message type required since the protocol should
    // read data from those messages that contain the block
    return false;
  }
}

//Backend.SLICC.ModularSLICC.msg.GenMsgStruct
structure(CoherenceMessage, desc="...", interface="Message") {
  Addr LineAddress,             desc="Physical address for this request";
  CoherenceMessageType Type,   desc="Type of request (GetS, GetM, PutM, etc)";
  MachineID Sender,            desc="Node who initiated the request";
  NetDest Destination,         desc="Multicast destination mask";
  MessageSizeType MessageSize, desc="size category of the message";
  bool exclusiveL1, desc="Boolean exclusiveL1";
  int acksExpectedL1, desc="Integer acksExpectedL1";
  DataBlock cl, desc="Cache line / Data cl";


  bool functionalRead(Packet *pkt) {
    // A check on message type should appear here so that only those
    // messages that contain data
    return testAndRead(LineAddress, cl, pkt);
  }

  bool functionalWrite(Packet *pkt) {
    // No check on message type required since the protocol should read
    // data block from only those messages that contain valid data
    return testAndWrite(LineAddress, cl, pkt);
  }
}

