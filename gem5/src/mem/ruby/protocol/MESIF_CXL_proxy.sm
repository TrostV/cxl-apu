//Backend.SLICC.ModularSLICC.proxy.GenProxyHeader
machine(MachineType:L0Cache, "Proxy cache controller")
: CacheMemory *cache;

  // The following latencies should be exposed as command-line parameters in a future update
  Cycles responseLatency := 1;
  Cycles recycleLatency := 10;

  // Dynamic networks
  MessageBuffer *fwdTo,    network="To",   virtual_network="12", vnet_type="fwd";
  MessageBuffer *fwdFrom,  network="From", virtual_network="12", vnet_type="fwd";
  MessageBuffer *respTo,   network="To",   virtual_network="13", vnet_type="resp";
  MessageBuffer *respFrom, network="From", virtual_network="13", vnet_type="resp";
  MessageBuffer *reqTo,    network="To",   virtual_network="14", vnet_type="req";
  MessageBuffer *reqFrom,  network="From", virtual_network="14", vnet_type="req";

  MessageBuffer *bisnpTo,   network="To",   virtual_network="6", vnet_type="bisnp";
  MessageBuffer *bisnpFrom, network="From", virtual_network="6", vnet_type="bisnp";
  MessageBuffer *birspTo,   network="To",   virtual_network="7", vnet_type="birsp";
  MessageBuffer *birspFrom, network="From", virtual_network="7", vnet_type="birsp";

  MessageBuffer *ndrTo,   network="To",   virtual_network="8", vnet_type="ndr";
  MessageBuffer *ndrFrom, network="From", virtual_network="8", vnet_type="ndr";
  MessageBuffer *drsTo,   network="To",   virtual_network="9", vnet_type="drs";
  MessageBuffer *drsFrom, network="From", virtual_network="9", vnet_type="drs";

  MessageBuffer *req2To,   network="To",   virtual_network="10", vnet_type="req2";
  MessageBuffer *req2From, network="From", virtual_network="10", vnet_type="req2";
  MessageBuffer *rwdTo,    network="To",   virtual_network="11", vnet_type="rwd";
  MessageBuffer *rwdFrom,  network="From", virtual_network="11", vnet_type="rwd";

{
  //Backend.SLICC.ModularSLICC.proxy.GenProxyStateDecl
  state_declaration(State, desc="L0Cache states", default="L0Cache_State_I__C__I") {
    BIConflictAckL2I__C__M_BIConflictAck, AccessPermission:Busy, desc="... TODO ...";
    BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, AccessPermission:Busy, desc="... TODO ...";
    BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, AccessPermission:Busy, desc="... TODO ...";
    BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, AccessPermission:Busy, desc="... TODO ...";
    BIConflictAckL2dF_GetM_x_pI_store__C__E, AccessPermission:Busy, desc="... TODO ...";
    BIConflictAckL2dF_GetM_x_pI_store__C__M, AccessPermission:Busy, desc="... TODO ...";
    BIConflictAckL2dF_GetM_x_pI_store__C__S, AccessPermission:Busy, desc="... TODO ...";
    BIConflictAckL2dF_GetM_x_pM__C__E, AccessPermission:Busy, desc="... TODO ...";
    BIConflictAckL2dF_GetM_x_pM__C__M, AccessPermission:Busy, desc="... TODO ...";
    BIConflictAckL2dF_GetM_x_pM__C__S, AccessPermission:Busy, desc="... TODO ...";
    BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__E, AccessPermission:Busy, desc="... TODO ...";
    BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__M, AccessPermission:Busy, desc="... TODO ...";
    BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__S, AccessPermission:Busy, desc="... TODO ...";
    BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__E, AccessPermission:Busy, desc="... TODO ...";
    BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__I_store, AccessPermission:Busy, desc="... TODO ...";
    BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__M, AccessPermission:Busy, desc="... TODO ...";
    BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__S, AccessPermission:Busy, desc="... TODO ...";
    BIConflictAckL2dM_x_pI_store__C__E, AccessPermission:Busy, desc="... TODO ...";
    BIConflictAckL2dM_x_pI_store__C__M, AccessPermission:Busy, desc="... TODO ...";
    BIConflictAckL2dM_x_pI_store__C__S, AccessPermission:Busy, desc="... TODO ...";
    BISnpDataL2I__C__M_BISnpData, AccessPermission:Busy, desc="... TODO ...";
    BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, AccessPermission:Busy, desc="... TODO ...";
    BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, AccessPermission:Busy, desc="... TODO ...";
    BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, AccessPermission:Busy, desc="... TODO ...";
    BISnpDataL2dF_GetM_x_pI_store__C__E, AccessPermission:Busy, desc="... TODO ...";
    BISnpDataL2dF_GetM_x_pI_store__C__M, AccessPermission:Busy, desc="... TODO ...";
    BISnpDataL2dF_GetM_x_pI_store__C__S, AccessPermission:Busy, desc="... TODO ...";
    BISnpDataL2dF_GetM_x_pM__C__E, AccessPermission:Busy, desc="... TODO ...";
    BISnpDataL2dF_GetM_x_pM__C__M, AccessPermission:Busy, desc="... TODO ...";
    BISnpDataL2dF_GetM_x_pM__C__S, AccessPermission:Busy, desc="... TODO ...";
    BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__E, AccessPermission:Busy, desc="... TODO ...";
    BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__M, AccessPermission:Busy, desc="... TODO ...";
    BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__S, AccessPermission:Busy, desc="... TODO ...";
    BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__E, AccessPermission:Busy, desc="... TODO ...";
    BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__M, AccessPermission:Busy, desc="... TODO ...";
    BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__S, AccessPermission:Busy, desc="... TODO ...";
    BISnpDataL2dM_x_pI_store__C__E, AccessPermission:Busy, desc="... TODO ...";
    BISnpDataL2dM_x_pI_store__C__M, AccessPermission:Busy, desc="... TODO ...";
    BISnpDataL2dM_x_pI_store__C__S, AccessPermission:Busy, desc="... TODO ...";
    BISnpInvL2I__C__M_BISnpInv, AccessPermission:Read_Only, desc="... TODO ...";
    BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, AccessPermission:Read_Only, desc="... TODO ...";
    BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, AccessPermission:Read_Only, desc="... TODO ...";
    BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, AccessPermission:Read_Only, desc="... TODO ...";
    BISnpInvL2dF_GetM_x_pI_store__C__E, AccessPermission:Busy, desc="... TODO ...";
    BISnpInvL2dF_GetM_x_pI_store__C__M, AccessPermission:Busy, desc="... TODO ...";
    BISnpInvL2dF_GetM_x_pI_store__C__S, AccessPermission:Busy, desc="... TODO ...";
    BISnpInvL2dF_GetM_x_pM__C__E, AccessPermission:Busy, desc="... TODO ...";
    BISnpInvL2dF_GetM_x_pM__C__M, AccessPermission:Busy, desc="... TODO ...";
    BISnpInvL2dF_GetM_x_pM__C__S, AccessPermission:Busy, desc="... TODO ...";
    BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__E, AccessPermission:Busy, desc="... TODO ...";
    BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__M, AccessPermission:Busy, desc="... TODO ...";
    BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__S, AccessPermission:Busy, desc="... TODO ...";
    BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__E, AccessPermission:Busy, desc="... TODO ...";
    BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__M, AccessPermission:Busy, desc="... TODO ...";
    BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__S, AccessPermission:Busy, desc="... TODO ...";
    BISnpInvL2dM_x_pI_store__C__E, AccessPermission:Busy, desc="... TODO ...";
    BISnpInvL2dM_x_pI_store__C__M, AccessPermission:Busy, desc="... TODO ...";
    BISnpInvL2dM_x_pI_store__C__S, AccessPermission:Busy, desc="... TODO ...";

    GetML1F_GetM__C__M, AccessPermission:Busy, desc="... TODO ...";
    GetML1F__C__I_store, AccessPermission:Busy, desc="... TODO ...";
    GetML1F__C__I_store_Cmp_E, AccessPermission:Busy, desc="... TODO ...";
    GetML1I__C__I_store, AccessPermission:Busy, desc="... TODO ...";
    GetML1I__C__I_store_Cmp_E, AccessPermission:Busy, desc="... TODO ...";
    GetML1S__C__I_store, AccessPermission:Busy, desc="... TODO ...";
    GetML1S__C__I_store_Cmp_E, AccessPermission:Busy, desc="... TODO ...";
    GetML1I__C__S_store, AccessPermission:Read_Only, desc="... TODO ...";
    GetML1S__C__S_store, AccessPermission:Read_Only, desc="... TODO ...";
    GetML1F__C__S_store, AccessPermission:Read_Only, desc="... TODO ...";

    GetSL1E_GetS__C__M, AccessPermission:Busy, desc="... TODO ...";
    GetSL1F_GetS__C__E, AccessPermission:Busy, desc="... TODO ...";
    GetSL1F_GetS__C__M, AccessPermission:Busy, desc="... TODO ...";
    GetSL1F_GetS__C__S, AccessPermission:Busy, desc="... TODO ...";
    GetSL1I__C__I_store, AccessPermission:Busy, desc="... TODO ...";
    GetSL1I__C__I_store_Cmp_E, AccessPermission:Busy, desc="... TODO ...";
    GetSL1I__C__I_store_Cmp_S, AccessPermission:Busy, desc="... TODO ...";
    GetSL1I__C__S_store, AccessPermission:Busy, desc="... TODO ...";
    GetSL1M_GetS__C__M, AccessPermission:Busy, desc="... TODO ...";

    E__C__M, AccessPermission:Maybe_Stale, desc="... TODO ...";
    F__C__E, AccessPermission:Read_Only, desc="... TODO ...";
    F__C__M, AccessPermission:Read_Only, desc="... TODO ...";
    F__C__S, AccessPermission:Read_Only, desc="... TODO ...";
    I__C__E, AccessPermission:Read_Write, desc="... TODO ...";
    I__C__I, AccessPermission:Invalid, desc="... TODO ...";
    I__C__M, AccessPermission:Read_Write, desc="... TODO ...";
    I__C__S, AccessPermission:Read_Only, desc="... TODO ...";
    M__C__M, AccessPermission:Maybe_Stale, desc="... TODO ...";
    S__C__E, AccessPermission:Read_Only, desc="... TODO ...";
    S__C__M, AccessPermission:Read_Only, desc="... TODO ...";
    S__C__S, AccessPermission:Read_Only, desc="... TODO ...";

    evictI__C__E_evict, AccessPermission:Busy, desc="... TODO ...";
    evictI__C__E_evict_x_I, AccessPermission:Read_Only, desc="... TODO ...";
    evictI__C__M_evict, AccessPermission:Read_Only, desc="... TODO ...";
    evictI__C__M_evict_BIConflictAck, AccessPermission:Read_Only, desc="... TODO ...";
    evictI__C__S_evict, AccessPermission:Read_Only, desc="... TODO ...";
    evictI__C__S_evict_x_I, AccessPermission:Read_Only, desc="... TODO ...";
    evictdF_GetM_x_pI_store_GetF_Ack_AD__C__E, AccessPermission:Read_Only, desc="... TODO ...";
    evictdF_GetM_x_pI_store_GetF_Ack_AD__C__M, AccessPermission:Read_Only, desc="... TODO ...";
    evictdF_GetM_x_pI_store_GetF_Ack_AD__C__S, AccessPermission:Read_Only, desc="... TODO ...";
    evictdF_GetM_x_pI_store__C__E, AccessPermission:Busy, desc="... TODO ...";
    evictdF_GetM_x_pI_store__C__M, AccessPermission:Busy, desc="... TODO ...";
    evictdF_GetM_x_pI_store__C__S, AccessPermission:Busy, desc="... TODO ...";
    evictdF_GetM_x_pM__C__E, AccessPermission:Busy, desc="... TODO ...";
    evictdF_GetM_x_pM__C__M, AccessPermission:Busy, desc="... TODO ...";
    evictdF_GetM_x_pM__C__S, AccessPermission:Busy, desc="... TODO ...";
    evictdM_x_pI_store_GetF_Ack_AD__C__E, AccessPermission:Busy, desc="... TODO ...";
    evictdM_x_pI_store_GetF_Ack_AD__C__M, AccessPermission:Busy, desc="... TODO ...";
    evictdM_x_pI_store_GetF_Ack_AD__C__S, AccessPermission:Busy, desc="... TODO ...";
    evictdM_x_pI_store_GetM_Ack_AD__C__E, AccessPermission:Busy, desc="... TODO ...";
    evictdM_x_pI_store_GetM_Ack_AD__C__M, AccessPermission:Busy, desc="... TODO ...";
    evictdM_x_pI_store_GetM_Ack_AD__C__S, AccessPermission:Busy, desc="... TODO ...";
    evictdM_x_pI_store__C__E, AccessPermission:Busy, desc="... TODO ...";
    evictdM_x_pI_store__C__M, AccessPermission:Busy, desc="... TODO ...";
    evictdM_x_pI_store__C__S, AccessPermission:Busy, desc="... TODO ...";
  }
  
  //Backend.SLICC.ModularSLICC.proxy.GenProxyEvents
  enumeration(Event, desc="Cache events") {
    deallocbirspfrom_in, desc="Event indicating the cache line + tbe should be deallocated following a message received on birspfrom_in.";
    Stallbirspfrom_in, desc="Stall the birspfrom_in port.";

    deallocbisnpfrom_in, desc="Event indicating the cache line + tbe should be deallocated following a message received on bisnpfrom_in.";
    Stallbisnpfrom_in, desc="Stall the bisnpfrom_in port.";

    deallocdrsfrom_in, desc="Event indicating the cache line + tbe should be deallocated following a message received on drsfrom_in.";
    Stalldrsfrom_in, desc="Stall the drsfrom_in port.";

    deallocfwdfrom_in, desc="Event indicating the cache line + tbe should be deallocated following a message received on fwdfrom_in.";
    Stallfwdfrom_in, desc="Stall the fwdfrom_in port.";

    deallocndrfrom_in, desc="Event indicating the cache line + tbe should be deallocated following a message received on ndrfrom_in.";
    Stallndrfrom_in, desc="Stall the ndrfrom_in port.";

    deallocreq2from_in, desc="Event indicating the cache line + tbe should be deallocated following a message received on req2from_in.";
    Stallreq2from_in, desc="Stall the req2from_in port.";

    deallocreqfrom_in, desc="Event indicating the cache line + tbe should be deallocated following a message received on reqfrom_in.";
    Stallreqfrom_in, desc="Stall the reqfrom_in port.";

    deallocrespfrom_in, desc="Event indicating the cache line + tbe should be deallocated following a message received on respfrom_in.";
    Stallrespfrom_in, desc="Stall the respfrom_in port.";

    deallocrwdfrom_in, desc="Event indicating the cache line + tbe should be deallocated following a message received on rwdfrom_in.";
    Stallrwdfrom_in, desc="Stall the rwdfrom_in port.";

    allocCacheEntry, desc="Allocate a new cache entry.";

    allocTBE, desc="Allocate a new TBE.";

    deallocTBE, desc="Deallocate a TBE.";
    deallocevict, desc="Deallocate Entry and copy to TBE while waiting for completion ACK.";

    Progress, desc="Progress, please!";
  }
  
  //Backend.SLICC.ModularSLICC.proxy.GenProxyStruct
  structure(Entry, desc="Stored variables of the Proxy machine", interface="AbstractCacheEntry") {
    State ProxyState, desc="Proxy state";
    DataBlock cl, desc="... TODO ...";
    NetDest cacheL1, desc="... TODO ...";
    MachineID ownerL1, desc="... TODO ...";
    MachineID proxy_msgL1_src, desc="... TODO ...";
    MachineID proxy_msgL2_src, desc="... TODO ...";
  }
  
  //Backend.SLICC.ModularSLICC.proxy.GenProxyTBE
  structure(TBE, desc="TBE entries for L0Cache machine") {
    State TBEState,       desc="Transient State";
    int acksReceivedL1, default=0, desc="...TODO...";
    int acksExpectedL1, default=0, desc="...TODO...";
    bool dirty, desc="Is the data dirty (different than memory)?";
    DataBlock cl, desc="... TODO ...";
    bool proxy_msgL1_exclusiveL1, desc="... TODO ...";
  }
  
  structure(TBETable, external="yes"){
    TBE lookup(Addr);
    void allocate(Addr);
    void deallocate(Addr);
    bool isPresent(Addr);
    bool areNSlotsAvailable(int, Tick);
  }
  
  TBETable TBEs, template="<L0Cache_TBE>", constructor="m_number_of_TBEs";
  
  
  //Backend.SLICC.ModularSLICC.proxy.GenProxyStaticFns
  Tick clockEdge();
  Tick cyclesToTicks(Cycles c);
  Cycles ticksToCycles(Tick t);
  void set_cache_entry(AbstractCacheEntry a);
  void unset_cache_entry();
  void set_tbe(TBE a);
  void unset_tbe();
  void wakeUpAllBuffers(Addr a);
  
  MachineID mapAddressToMachine(Addr addr, MachineType mtype);
  
  Entry getEntry(Addr LineAddress), return_by_pointer="yes" {
    return static_cast(Entry, "pointer", cache.lookup(LineAddress));
  }

  DataBlock getCacheBlock(TBE tbe, Entry cache_entry, Addr LineAddress) {
    if (is_valid(cache_entry)) {
      return cache_entry.cl;
    } else if (is_valid(tbe) && tbe.dirty) {
      return tbe.cl;
    } else {
      error("Block not present!");
    }
  }

  void setCacheBlock(TBE tbe, Entry cache_entry, Addr LineAddress, DataBlock cl) {
    if (is_valid(cache_entry)) {
      cache_entry.cl := cl;
    } else if (is_valid(tbe) && tbe.dirty) {
      tbe.cl := cl;
    } else {
      error("Block not present!");
    }
  }
  
  State getState(TBE tbe, Entry cache_entry, Addr LineAddress) {
    if (is_valid(tbe)) {
      return tbe.TBEState;
    } else if (is_valid(cache_entry)) {
      return cache_entry.ProxyState;
    } else {
      return State:I__C__I;
    }
  }
  
  void setState(TBE tbe, Entry cache_entry, Addr LineAddress, State state) {
    DPRINTF(RubySlicc, "%s -> %s (addr: %#x)\n", getState(tbe, cache_entry, LineAddress), state, LineAddress);
    //if (state != getState(tbe, cache_entry, LineAddress)) {
      //  wakeUpAllBuffers(LineAddress);
      //}
      if (state == State:I__C__I || state == State:I__C__S || state == State:I__C__E || state == State:I__C__M ||
          state == State:S__C__S || state == State:S__C__E || state == State:S__C__M ||
          state == State:F__C__E || state == State:F__C__M || state == State:F__C__S ||
          state == State:E__C__M ||
          state == State:M__C__M ) {
        wakeUpAllBuffers(LineAddress);
      }
      if (is_valid(tbe)) {
        tbe.TBEState := state;
      }
      if (is_valid(cache_entry)) {
        cache_entry.ProxyState := state;
      }
    }
    
    AccessPermission getAccessPermission(Addr LineAddress) {
      TBE tbe := TBEs[LineAddress];
      if (is_valid(tbe)) {
        return L0Cache_State_to_permission(tbe.TBEState);
      }
      Entry cache_entry := getEntry(LineAddress);
      if (is_valid(cache_entry)) {
        return L0Cache_State_to_permission(cache_entry.ProxyState);
      } else {
        return AccessPermission:NotPresent;
      }
    }
    
    void setAccessPermission(Entry cache_entry, Addr LineAddress, State state) {
      if (is_valid(cache_entry)) {
        cache_entry.changePermission(L0Cache_State_to_permission(state));
      }
    }

    void functionalRead(Addr addr, Packet *pkt) {
      TBE tbe := TBEs[addr];
      Entry cache_entry := getEntry(addr);
      if (is_valid(cache_entry)) {
        testAndRead(addr, cache_entry.cl, pkt);
      } else if(is_valid(tbe) && tbe.dirty) {
        testAndRead(addr, tbe.cl, pkt);
      } else {
        error("Block not present!");                                                                                                                               }
    }
    
    int functionalWrite(Addr addr, Packet *pkt) {
      int num_functional_writes := 0;
      Entry cache_entry := getEntry(addr);
      if (is_valid(cache_entry)) {
        num_functional_writes := num_functional_writes +
          testAndWrite(addr, cache_entry.cl, pkt);
        return num_functional_writes;
      }
      TBE tbe := TBEs[addr];
      if(is_valid(tbe) && tbe.dirty) {
        num_functional_writes := num_functional_writes +
        testAndWrite(addr, tbe.cl, pkt);
      }
      return num_functional_writes;
    }
    
    //Backend.SLICC.ModularSLICC.proxy.GenProxyOutPorts
    out_port(birspto_out, CoherenceMessage, birspTo);
    out_port(bisnpto_out, CoherenceMessage, bisnpTo);
    out_port(drsto_out, CoherenceMessage, drsTo);
    out_port(fwdto_out, CoherenceMessage, fwdTo);
    out_port(ndrto_out, CoherenceMessage, ndrTo);
    out_port(req2to_out, CoherenceMessage, req2To);
    out_port(reqto_out, CoherenceMessage, reqTo);
    out_port(respto_out, CoherenceMessage, respTo);
    out_port(rwdto_out, CoherenceMessage, rwdTo);
    
    //Backend.SLICC.ModularSLICC.proxy.GenProxyInPorts
    in_port(ndrfrom_in, CoherenceMessage, ndrFrom, rank=2) {
      if (ndrfrom_in.isReady(clockEdge())) {
        peek (ndrfrom_in, CoherenceMessage, block_on="LineAddress") {
          Addr LineAddress := in_msg.LineAddress;
          TBE tbe := TBEs[LineAddress];
          State st := getState(tbe, getEntry(LineAddress), LineAddress);
          DPRINTF(RubySlicc, "ndrfrom_in: %s %s %s (addr: %#x)\n", in_msg.Type, in_msg.Sender, st, LineAddress);
          if (st == State:BIConflictAckL2I__C__M_BIConflictAck) {
            if (in_msg.Type == CoherenceMessageType:CmpL2) {
              enqueue(birspto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIRspIL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
              trigger(Event:deallocndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpDataL2I__C__M_BISnpData) {
            if (in_msg.Type == CoherenceMessageType:CmpL2) {
              enqueue(birspto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIRspSL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              ndrfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpInvL2I__C__M_BISnpInv) {
            if (in_msg.Type == CoherenceMessageType:CmpL2) {
              enqueue(birspto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIRspIL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
              trigger(Event:deallocndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:E__C__M) {
            if (in_msg.Type == CoherenceMessageType:BIConflictAckL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on ndrfrom_in (addr: %#x)\n", st, LineAddress);
                  ndrfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                out_msg.Sender := machineID;
                out_msg.acksExpectedL1 := 0;
              }
              getEntry(LineAddress).ownerL1 := machineID;
              getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
              setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              ndrfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:F__C__E) {
            if (in_msg.Type == CoherenceMessageType:BIConflictAckL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on ndrfrom_in (addr: %#x)\n", st, LineAddress);
                  ndrfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID != getEntry(LineAddress).ownerL1) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                  out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                  out_msg.Sender := machineID;
                  out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                }
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := machineID;
                  }
                  getEntry(LineAddress).ownerL1 := machineID;
                  getEntry(LineAddress).cacheL1.clear();
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dF_GetM_x_pI_store__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  ndrfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() == 0) {
                  getEntry(LineAddress).ownerL1 := machineID;
                  getEntry(LineAddress).cacheL1.clear();
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dF_GetM_x_pI_store__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  ndrfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:F__C__M) {
            if (in_msg.Type == CoherenceMessageType:BIConflictAckL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on ndrfrom_in (addr: %#x)\n", st, LineAddress);
                  ndrfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID != getEntry(LineAddress).ownerL1) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                  out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                  out_msg.Sender := machineID;
                  out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                }
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := machineID;
                  }
                  getEntry(LineAddress).ownerL1 := machineID;
                  getEntry(LineAddress).cacheL1.clear();
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dF_GetM_x_pI_store__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  ndrfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() == 0) {
                  getEntry(LineAddress).ownerL1 := machineID;
                  getEntry(LineAddress).cacheL1.clear();
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dF_GetM_x_pI_store__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  ndrfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:F__C__S) {
            if (in_msg.Type == CoherenceMessageType:BIConflictAckL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on ndrfrom_in (addr: %#x)\n", st, LineAddress);
                  ndrfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID != getEntry(LineAddress).ownerL1) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                  out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                  out_msg.Sender := machineID;
                  out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                }
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := machineID;
                  }
                  getEntry(LineAddress).ownerL1 := machineID;
                  getEntry(LineAddress).cacheL1.clear();
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dF_GetM_x_pI_store__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  ndrfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() == 0) {
                  getEntry(LineAddress).ownerL1 := machineID;
                  getEntry(LineAddress).cacheL1.clear();
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dF_GetM_x_pI_store__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  ndrfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetML1F__C__I_store) {
            if (in_msg.Type == CoherenceMessageType:BIConflictAckL2) {
              enqueue(birspto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIRspIL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F__C__I_store);
              DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              ndrfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:Cmp_EL2) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F__C__I_store_Cmp_E);
              DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              ndrfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetML1F__C__S_store) {
            if (in_msg.Type == CoherenceMessageType:BIConflictAckL2) {
              enqueue(birspto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIRspIL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F__C__I_store);
              DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              ndrfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:Cmp_EL2) {
              getEntry(LineAddress).cacheL1.remove(getEntry(LineAddress).proxy_msgL1_src);
              if (getEntry(LineAddress).proxy_msgL1_src == getEntry(LineAddress).ownerL1) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                  out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                }
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                  }
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  ndrfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() == 0) {
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  ndrfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).proxy_msgL1_src != getEntry(LineAddress).ownerL1) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                  out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                  out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                  out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                }
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                  }
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  ndrfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() == 0) {
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  ndrfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetML1I__C__I_store) {
            if (in_msg.Type == CoherenceMessageType:BIConflictAckL2) {
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.clear();
              getEntry(LineAddress).ownerL1 := machineID;
              tbe.acksExpectedL1 := 0;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspIL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1I__C__I_store);
                  DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  ndrfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else if (in_msg.Type == CoherenceMessageType:Cmp_EL2) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1I__C__I_store_Cmp_E);
              DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              ndrfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetML1I__C__S_store) {
            if (in_msg.Type == CoherenceMessageType:BIConflictAckL2) {
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.clear();
              getEntry(LineAddress).ownerL1 := machineID;
              tbe.acksExpectedL1 := 0;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspIL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1I__C__I_store);
                  DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  ndrfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else if (in_msg.Type == CoherenceMessageType:Cmp_EL2) {
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                out_msg.acksExpectedL1 := 0;
              }
              getEntry(LineAddress).cacheL1.clear();
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              ndrfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetML1S__C__I_store) {
            if (in_msg.Type == CoherenceMessageType:BIConflictAckL2) {
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (getEntry(LineAddress).cacheL1.count() != 0) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1;
                  out_msg.Type := CoherenceMessageType:InvL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).ownerL1 := machineID;
                tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                getEntry(LineAddress).cacheL1.clear();
                if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                  getEntry(LineAddress).cacheL1.remove(machineID);
                  if (machineID == getEntry(LineAddress).ownerL1) {
                    getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                    enqueue(birspto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Control;
                      out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                      out_msg.Type := CoherenceMessageType:BIRspIL2;
                      out_msg.Sender := machineID;
                    }
                    setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1S__C__I_store);
                    DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                    ndrfrom_in.dequeue(clockEdge());
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__I_store);
                  DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  ndrfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else if (in_msg.Type == CoherenceMessageType:Cmp_EL2) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1S__C__I_store_Cmp_E);
              DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              ndrfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetML1S__C__S_store) {
            if (in_msg.Type == CoherenceMessageType:BIConflictAckL2) {
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (getEntry(LineAddress).cacheL1.count() != 0) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1;
                  out_msg.Type := CoherenceMessageType:InvL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).ownerL1 := machineID;
                tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                getEntry(LineAddress).cacheL1.clear();
                if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                  getEntry(LineAddress).cacheL1.remove(machineID);
                  if (machineID == getEntry(LineAddress).ownerL1) {
                    getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                    enqueue(birspto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Control;
                      out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                      out_msg.Type := CoherenceMessageType:BIRspIL2;
                      out_msg.Sender := machineID;
                    }
                    setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1S__C__I_store);
                    DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                    ndrfrom_in.dequeue(clockEdge());
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__I_store);
                  DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  ndrfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else if (in_msg.Type == CoherenceMessageType:Cmp_EL2) {
              getEntry(LineAddress).cacheL1.remove(getEntry(LineAddress).proxy_msgL1_src);
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
              }
              if (getEntry(LineAddress).cacheL1.count() != 0) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1;
                  out_msg.Type := CoherenceMessageType:InvL1;
                  out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                }
                getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                getEntry(LineAddress).cacheL1.clear();
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                ndrfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).cacheL1.count() == 0) {
                getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                getEntry(LineAddress).cacheL1.clear();
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                ndrfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetSL1I__C__I_store) {
            if (in_msg.Type == CoherenceMessageType:BIConflictAckL2) {
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.clear();
              getEntry(LineAddress).ownerL1 := machineID;
              tbe.acksExpectedL1 := 0;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspIL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1I__C__I_store);
                  DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  ndrfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else if (in_msg.Type == CoherenceMessageType:Cmp_EL2) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1I__C__I_store_Cmp_E);
              DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              ndrfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:Cmp_SL2) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1I__C__I_store_Cmp_S);
              DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              ndrfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetSL1I__C__S_store) {
            if (in_msg.Type == CoherenceMessageType:BIConflictAckL2) {
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.clear();
              getEntry(LineAddress).ownerL1 := machineID;
              tbe.acksExpectedL1 := 0;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspIL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1I__C__I_store);
                  DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  ndrfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else if (in_msg.Type == CoherenceMessageType:Cmp_EL2) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetM_Ack_DL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
              }
              getEntry(LineAddress).cacheL1.clear();
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              setState(tbe, getEntry(LineAddress), LineAddress, State:E__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              ndrfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:I__C__E) {
            if (in_msg.Type == CoherenceMessageType:BIConflictAckL2) {
              //tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.clear();
              getEntry(LineAddress).ownerL1 := machineID;
              //tbe.acksExpectedL1 := 0;
              //if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspIL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                  trigger(Event:deallocndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
                }
              //}
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:I__C__I) {
            if (in_msg.Type == CoherenceMessageType:BIConflictAckL2) {
              //tbe.acksReceivedL1 := 0;
              //getEntry(LineAddress).cacheL1.clear();
              //getEntry(LineAddress).ownerL1 := machineID;
              //tbe.acksExpectedL1 := 0;
              //if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
              //  getEntry(LineAddress).cacheL1.remove(machineID);
              //  if (machineID == getEntry(LineAddress).ownerL1) {
              //    getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
              //      out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Destination.add(in_msg.Sender);
                    out_msg.Type := CoherenceMessageType:BIRspIL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                  ndrfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                  //trigger(Event:deallocndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
                //}
              //}
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:I__C__M) {
            if (in_msg.Type == CoherenceMessageType:BIConflictAckL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on ndrfrom_in (addr: %#x)\n", st, LineAddress);
                  ndrfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.clear();
              getEntry(LineAddress).ownerL1 := machineID;
              tbe.acksExpectedL1 := 0;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:MemWr_IL2;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2I__C__M_BIConflictAck);
                  DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  ndrfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:I__C__S) {
            if (in_msg.Type == CoherenceMessageType:BIConflictAckL2) {
              //tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.clear();
              getEntry(LineAddress).ownerL1 := machineID;
              //tbe.acksExpectedL1 := 0;
              //if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspIL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                  trigger(Event:deallocndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
                }
              //}
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:M__C__M) {
            if (in_msg.Type == CoherenceMessageType:BIConflictAckL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on ndrfrom_in (addr: %#x)\n", st, LineAddress);
                  ndrfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                out_msg.Sender := machineID;
                out_msg.acksExpectedL1 := 0;
              }
              getEntry(LineAddress).ownerL1 := machineID;
              getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
              setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              ndrfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:S__C__E) {
            if (in_msg.Type == CoherenceMessageType:BIConflictAckL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on ndrfrom_in (addr: %#x)\n", st, LineAddress);
                  ndrfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (getEntry(LineAddress).cacheL1.count() != 0) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1;
                  out_msg.Type := CoherenceMessageType:InvL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).ownerL1 := machineID;
                tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                getEntry(LineAddress).cacheL1.clear();
                if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                  getEntry(LineAddress).cacheL1.remove(machineID);
                  if (machineID == getEntry(LineAddress).ownerL1) {
                    getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                    enqueue(birspto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Control;
                      out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                      out_msg.Type := CoherenceMessageType:BIRspIL2;
                      out_msg.Sender := machineID;
                    }
                    setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                    trigger(Event:deallocndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  ndrfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:S__C__M) {
            if (in_msg.Type == CoherenceMessageType:BIConflictAckL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on ndrfrom_in (addr: %#x)\n", st, LineAddress);
                  ndrfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (getEntry(LineAddress).cacheL1.count() != 0) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1;
                  out_msg.Type := CoherenceMessageType:InvL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).ownerL1 := machineID;
                tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                getEntry(LineAddress).cacheL1.clear();
                if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                  getEntry(LineAddress).cacheL1.remove(machineID);
                  if (machineID == getEntry(LineAddress).ownerL1) {
                    getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                    enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Data;
                      out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                      out_msg.Type := CoherenceMessageType:MemWr_IL2;
                      out_msg.Sender := machineID;
                      out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                    }
                    setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2I__C__M_BIConflictAck);
                    DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                    ndrfrom_in.dequeue(clockEdge());
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  ndrfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:S__C__S) {
            if (in_msg.Type == CoherenceMessageType:BIConflictAckL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on ndrfrom_in (addr: %#x)\n", st, LineAddress);
                  ndrfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (getEntry(LineAddress).cacheL1.count() != 0) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1;
                  out_msg.Type := CoherenceMessageType:InvL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).ownerL1 := machineID;
                tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                getEntry(LineAddress).cacheL1.clear();
                if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                  getEntry(LineAddress).cacheL1.remove(machineID);
                  if (machineID == getEntry(LineAddress).ownerL1) {
                    getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                    enqueue(birspto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Control;
                      out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                      out_msg.Type := CoherenceMessageType:BIRspIL2;
                      out_msg.Sender := machineID;
                    }
                    setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                    trigger(Event:deallocndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  ndrfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictI__C__E_evict) {
            if (in_msg.Type == CoherenceMessageType:BIConflictAckL2) {
              enqueue(birspto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIRspIL2;
                out_msg.Sender := machineID;
              }
              tbe.dirty := false;
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__E_evict_x_I);
              DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              ndrfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:CmpL2) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
              ndrfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              //trigger(Event:deallocndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictI__C__E_evict_x_I) {
            if (in_msg.Type == CoherenceMessageType:CmpL2) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
              ndrfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              //trigger(Event:deallocndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictI__C__M_evict) {
            if (in_msg.Type == CoherenceMessageType:BIConflictAckL2) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__M_evict_BIConflictAck);
              DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              ndrfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:CmpL2) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
              ndrfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              //trigger(Event:deallocndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictI__C__M_evict_BIConflictAck) {
            if (in_msg.Type == CoherenceMessageType:CmpL2) {
              enqueue(birspto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIRspIL2;
                out_msg.Sender := machineID;
              }
              tbe.dirty := false;
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
              ndrfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              //trigger(Event:deallocndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictI__C__S_evict) {
            if (in_msg.Type == CoherenceMessageType:BIConflictAckL2) {
              enqueue(birspto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIRspIL2;
                out_msg.Sender := machineID;
              }
              tbe.dirty := false;
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__S_evict_x_I);
              DPRINTF(RubySlicc, "Popping %s %s on ndrfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              ndrfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:CmpL2) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
              ndrfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              //trigger(Event:deallocndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictI__C__S_evict_x_I) {
            if (in_msg.Type == CoherenceMessageType:CmpL2) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
              ndrfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              //trigger(Event:deallocndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else {
            trigger(Event:Stallndrfrom_in, LineAddress, getEntry(LineAddress), tbe);
          }
        }
      }
    }
    
    in_port(fwdfrom_in, CoherenceMessage, fwdFrom, rank=0) {
      if (fwdfrom_in.isReady(clockEdge())) {
        peek (fwdfrom_in, CoherenceMessage, block_on="LineAddress") {
          Addr LineAddress := in_msg.LineAddress;
          TBE tbe := TBEs[LineAddress];
          State st := getState(tbe, getEntry(LineAddress), LineAddress);
          DPRINTF(RubySlicc, "fwdfrom_in: %s %s %s (addr: %#x)\n", in_msg.Type, in_msg.Sender, st, LineAddress);
          if (st == State:BIConflictAckL2dF_GetM_x_pI_store__C__E) {
            if (in_msg.Type == CoherenceMessageType:GetF_Ack_ADL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL1 := in_msg.acksExpectedL1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dF_GetM_x_pM__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BIConflictAckL2dF_GetM_x_pI_store__C__M) {
            if (in_msg.Type == CoherenceMessageType:GetF_Ack_ADL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL1 := in_msg.acksExpectedL1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dF_GetM_x_pM__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BIConflictAckL2dF_GetM_x_pI_store__C__S) {
            if (in_msg.Type == CoherenceMessageType:GetF_Ack_ADL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL1 := in_msg.acksExpectedL1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dF_GetM_x_pM__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BIConflictAckL2dM_x_pI_store__C__E) {
            if (in_msg.Type == CoherenceMessageType:GetF_Ack_ADL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL1 := in_msg.acksExpectedL1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspIL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                  trigger(Event:deallocfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BIConflictAckL2dM_x_pI_store__C__M) {
            if (in_msg.Type == CoherenceMessageType:GetF_Ack_ADL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL1 := in_msg.acksExpectedL1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:MemWr_IL2;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2I__C__M_BIConflictAck);
                  DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  fwdfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BIConflictAckL2dM_x_pI_store__C__S) {
            if (in_msg.Type == CoherenceMessageType:GetF_Ack_ADL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL1 := in_msg.acksExpectedL1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspIL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                  trigger(Event:deallocfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpDataL2dF_GetM_x_pI_store__C__E) {
            if (in_msg.Type == CoherenceMessageType:GetF_Ack_ADL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL1 := in_msg.acksExpectedL1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dF_GetM_x_pM__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpDataL2dF_GetM_x_pI_store__C__M) {
            if (in_msg.Type == CoherenceMessageType:GetF_Ack_ADL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL1 := in_msg.acksExpectedL1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dF_GetM_x_pM__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpDataL2dF_GetM_x_pI_store__C__S) {
            if (in_msg.Type == CoherenceMessageType:GetF_Ack_ADL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL1 := in_msg.acksExpectedL1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dF_GetM_x_pM__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpDataL2dM_x_pI_store__C__E) {
            if (in_msg.Type == CoherenceMessageType:GetF_Ack_ADL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL1 := in_msg.acksExpectedL1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspSL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  fwdfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpDataL2dM_x_pI_store__C__M) {
            if (in_msg.Type == CoherenceMessageType:GetF_Ack_ADL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL1 := in_msg.acksExpectedL1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:MemWr_SL2;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2I__C__M_BISnpData);
                  DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  fwdfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpDataL2dM_x_pI_store__C__S) {
            if (in_msg.Type == CoherenceMessageType:GetF_Ack_ADL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL1 := in_msg.acksExpectedL1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspSL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  fwdfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpInvL2dF_GetM_x_pI_store__C__E) {
            if (in_msg.Type == CoherenceMessageType:GetF_Ack_ADL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL1 := in_msg.acksExpectedL1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dF_GetM_x_pM__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpInvL2dF_GetM_x_pI_store__C__M) {
            if (in_msg.Type == CoherenceMessageType:GetF_Ack_ADL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL1 := in_msg.acksExpectedL1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dF_GetM_x_pM__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpInvL2dF_GetM_x_pI_store__C__S) {
            if (in_msg.Type == CoherenceMessageType:GetF_Ack_ADL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL1 := in_msg.acksExpectedL1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dF_GetM_x_pM__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpInvL2dM_x_pI_store__C__E) {
            if (in_msg.Type == CoherenceMessageType:GetF_Ack_ADL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL1 := in_msg.acksExpectedL1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspIL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                  trigger(Event:deallocfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpInvL2dM_x_pI_store__C__M) {
            if (in_msg.Type == CoherenceMessageType:GetF_Ack_ADL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL1 := in_msg.acksExpectedL1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:MemWr_IL2;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2I__C__M_BISnpInv);
                  DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  fwdfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpInvL2dM_x_pI_store__C__S) {
            if (in_msg.Type == CoherenceMessageType:GetF_Ack_ADL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL1 := in_msg.acksExpectedL1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspIL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                  trigger(Event:deallocfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdF_GetM_x_pI_store__C__E) {
            if (in_msg.Type == CoherenceMessageType:GetF_Ack_ADL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL1 := in_msg.acksExpectedL1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdF_GetM_x_pM__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdF_GetM_x_pI_store_GetF_Ack_AD__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdF_GetM_x_pI_store__C__M) {
            if (in_msg.Type == CoherenceMessageType:GetF_Ack_ADL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL1 := in_msg.acksExpectedL1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdF_GetM_x_pM__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdF_GetM_x_pI_store_GetF_Ack_AD__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdF_GetM_x_pI_store__C__S) {
            if (in_msg.Type == CoherenceMessageType:GetF_Ack_ADL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL1 := in_msg.acksExpectedL1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdF_GetM_x_pM__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdF_GetM_x_pI_store_GetF_Ack_AD__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdM_x_pI_store__C__E) {
            if (in_msg.Type == CoherenceMessageType:GetF_Ack_ADL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL1 := in_msg.acksExpectedL1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(req2to_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                    out_msg.Type := CoherenceMessageType:MemClnEvct_IL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__E_evict);
                  DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  fwdfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                  //trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store_GetF_Ack_AD__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdM_x_pI_store__C__M) {
            if (in_msg.Type == CoherenceMessageType:GetF_Ack_ADL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL1 := in_msg.acksExpectedL1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                    out_msg.Type := CoherenceMessageType:MemWr_IL2;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__M_evict);
                  DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  fwdfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                  //trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store_GetF_Ack_AD__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdM_x_pI_store__C__S) {
            if (in_msg.Type == CoherenceMessageType:GetF_Ack_ADL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL1 := in_msg.acksExpectedL1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(req2to_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                    out_msg.Type := CoherenceMessageType:MemClnEvct_IL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__S_evict);
                  DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  fwdfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                  //trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store_GetF_Ack_AD__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                fwdfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else {
            trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
          }
        }
      }
    }
    
    in_port(respfrom_in, CoherenceMessage, respFrom, rank=1) {
      if (respfrom_in.isReady(clockEdge())) {
        peek (respfrom_in, CoherenceMessage, block_on="LineAddress") {
          Addr LineAddress := in_msg.LineAddress;
          TBE tbe := TBEs[LineAddress];
          State st := getState(tbe, getEntry(LineAddress), LineAddress);
          DPRINTF(RubySlicc, "respfrom_in: %s %s %s (addr: %#x)\n", in_msg.Type, in_msg.Sender, st, LineAddress);
          if (st == State:BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dF_GetM_x_pM__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__E);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dF_GetM_x_pM__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dF_GetM_x_pM__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BIConflictAckL2dF_GetM_x_pI_store__C__E) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dF_GetM_x_pI_store__C__E);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store__C__E);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BIConflictAckL2dF_GetM_x_pI_store__C__M) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dF_GetM_x_pI_store__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BIConflictAckL2dF_GetM_x_pI_store__C__S) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dF_GetM_x_pI_store__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BIConflictAckL2dF_GetM_x_pM__C__E) {
            if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID == getEntry(LineAddress).ownerL1) {
                enqueue(birspto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                  out_msg.Type := CoherenceMessageType:BIRspIL2;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                trigger(Event:deallocrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BIConflictAckL2dF_GetM_x_pM__C__M) {
            if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID == getEntry(LineAddress).ownerL1) {
                enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                  out_msg.Type := CoherenceMessageType:MemWr_IL2;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2I__C__M_BIConflictAck);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BIConflictAckL2dF_GetM_x_pM__C__S) {
            if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID == getEntry(LineAddress).ownerL1) {
                enqueue(birspto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                  out_msg.Type := CoherenceMessageType:BIRspIL2;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                trigger(Event:deallocrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__E) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspIL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                  trigger(Event:deallocrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__M) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:MemWr_IL2;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2I__C__M_BIConflictAck);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__S) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspIL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                  trigger(Event:deallocrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__E) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspIL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                  trigger(Event:deallocrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__I_store) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspIL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1S__C__I_store);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__I_store);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__M) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:MemWr_IL2;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2I__C__M_BIConflictAck);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__S) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspIL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                  trigger(Event:deallocrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BIConflictAckL2dM_x_pI_store__C__E) {
            if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID == getEntry(LineAddress).ownerL1) {
                enqueue(birspto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                  out_msg.Type := CoherenceMessageType:BIRspIL2;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                trigger(Event:deallocrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store__C__E);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BIConflictAckL2dM_x_pI_store__C__M) {
            if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID == getEntry(LineAddress).ownerL1) {
                enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                  out_msg.Type := CoherenceMessageType:MemWr_IL2;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2I__C__M_BIConflictAck);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BIConflictAckL2dM_x_pI_store__C__S) {
            if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID == getEntry(LineAddress).ownerL1) {
                enqueue(birspto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                  out_msg.Type := CoherenceMessageType:BIRspIL2;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                trigger(Event:deallocrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:BIConflictAckL2dM_x_pI_store__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dF_GetM_x_pM__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__E);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dF_GetM_x_pM__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dF_GetM_x_pM__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpDataL2dF_GetM_x_pI_store__C__E) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dF_GetM_x_pI_store__C__E);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dM_x_pI_store__C__E);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpDataL2dF_GetM_x_pI_store__C__M) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dF_GetM_x_pI_store__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dM_x_pI_store__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpDataL2dF_GetM_x_pI_store__C__S) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dF_GetM_x_pI_store__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dM_x_pI_store__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpDataL2dF_GetM_x_pM__C__E) {
            if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID == getEntry(LineAddress).ownerL1) {
                enqueue(birspto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                  out_msg.Type := CoherenceMessageType:BIRspSL2;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpDataL2dF_GetM_x_pM__C__M) {
            if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID == getEntry(LineAddress).ownerL1) {
                enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                  out_msg.Type := CoherenceMessageType:MemWr_SL2;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2I__C__M_BISnpData);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpDataL2dF_GetM_x_pM__C__S) {
            if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID == getEntry(LineAddress).ownerL1) {
                enqueue(birspto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                  out_msg.Type := CoherenceMessageType:BIRspSL2;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__E) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspSL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__M) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:MemWr_SL2;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2I__C__M_BISnpData);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__S) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspSL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__E) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspSL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__M) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:MemWr_SL2;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2I__C__M_BISnpData);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__S) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspSL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpDataL2dM_x_pI_store__C__E) {
            if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID == getEntry(LineAddress).ownerL1) {
                enqueue(birspto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                  out_msg.Type := CoherenceMessageType:BIRspSL2;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dM_x_pI_store__C__E);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpDataL2dM_x_pI_store__C__M) {
            if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID == getEntry(LineAddress).ownerL1) {
                enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                  out_msg.Type := CoherenceMessageType:MemWr_SL2;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2I__C__M_BISnpData);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dM_x_pI_store__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpDataL2dM_x_pI_store__C__S) {
            if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID == getEntry(LineAddress).ownerL1) {
                enqueue(birspto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                  out_msg.Type := CoherenceMessageType:BIRspSL2;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dM_x_pI_store__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dF_GetM_x_pM__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__E);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dF_GetM_x_pM__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dF_GetM_x_pM__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpInvL2dF_GetM_x_pI_store__C__E) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dF_GetM_x_pI_store__C__E);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dM_x_pI_store__C__E);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpInvL2dF_GetM_x_pI_store__C__M) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dF_GetM_x_pI_store__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dM_x_pI_store__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpInvL2dF_GetM_x_pI_store__C__S) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dF_GetM_x_pI_store__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dM_x_pI_store__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpInvL2dF_GetM_x_pM__C__E) {
            if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID == getEntry(LineAddress).ownerL1) {
                enqueue(birspto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                  out_msg.Type := CoherenceMessageType:BIRspIL2;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                trigger(Event:deallocrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpInvL2dF_GetM_x_pM__C__M) {
            if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID == getEntry(LineAddress).ownerL1) {
                enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                  out_msg.Type := CoherenceMessageType:MemWr_IL2;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2I__C__M_BISnpInv);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpInvL2dF_GetM_x_pM__C__S) {
            if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID == getEntry(LineAddress).ownerL1) {
                enqueue(birspto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                  out_msg.Type := CoherenceMessageType:BIRspIL2;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                trigger(Event:deallocrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__E) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspIL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                  trigger(Event:deallocrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__M) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:MemWr_IL2;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2I__C__M_BISnpInv);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__S) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspIL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                  trigger(Event:deallocrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__E) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspIL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                  trigger(Event:deallocrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__M) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:MemWr_IL2;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2I__C__M_BISnpInv);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__S) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspIL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                  trigger(Event:deallocrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpInvL2dM_x_pI_store__C__E) {
            if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID == getEntry(LineAddress).ownerL1) {
                enqueue(birspto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                  out_msg.Type := CoherenceMessageType:BIRspIL2;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                trigger(Event:deallocrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dM_x_pI_store__C__E);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpInvL2dM_x_pI_store__C__M) {
            if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID == getEntry(LineAddress).ownerL1) {
                enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                  out_msg.Type := CoherenceMessageType:MemWr_IL2;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2I__C__M_BISnpInv);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dM_x_pI_store__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:BISnpInvL2dM_x_pI_store__C__S) {
            if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID == getEntry(LineAddress).ownerL1) {
                enqueue(birspto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                  out_msg.Type := CoherenceMessageType:BIRspIL2;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                trigger(Event:deallocrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dM_x_pI_store__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetML1F_GetM__C__M) {
            if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetSL1E_GetS__C__M) {
            if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:WBL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetSL1F_GetS__C__E) {
            if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__E);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetSL1F_GetS__C__M) {
            if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetSL1F_GetS__C__S) {
            if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetSL1M_GetS__C__M) {
            if (in_msg.Type == CoherenceMessageType:WBL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdF_GetM_x_pI_store_GetF_Ack_AD__C__E) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdF_GetM_x_pM__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdF_GetM_x_pI_store_GetF_Ack_AD__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store_GetF_Ack_AD__C__E);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdF_GetM_x_pI_store_GetF_Ack_AD__C__M) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdF_GetM_x_pM__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdF_GetM_x_pI_store_GetF_Ack_AD__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store_GetF_Ack_AD__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdF_GetM_x_pI_store_GetF_Ack_AD__C__S) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdF_GetM_x_pM__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdF_GetM_x_pI_store_GetF_Ack_AD__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store_GetF_Ack_AD__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdF_GetM_x_pI_store__C__E) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictdF_GetM_x_pI_store__C__E);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store__C__E);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdF_GetM_x_pI_store__C__M) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictdF_GetM_x_pI_store__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdF_GetM_x_pI_store__C__S) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictdF_GetM_x_pI_store__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdF_GetM_x_pM__C__E) {
            if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID == getEntry(LineAddress).ownerL1) {
                enqueue(req2to_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                  out_msg.Type := CoherenceMessageType:MemClnEvct_IL2;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__E_evict);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                //trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdF_GetM_x_pM__C__M) {
            if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID == getEntry(LineAddress).ownerL1) {
                enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                  out_msg.Type := CoherenceMessageType:MemWr_IL2;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__M_evict);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                //trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdF_GetM_x_pM__C__S) {
            if (in_msg.Type == CoherenceMessageType:UnblockL1) {
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID == getEntry(LineAddress).ownerL1) {
                enqueue(req2to_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                  out_msg.Type := CoherenceMessageType:MemClnEvct_IL2;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__S_evict);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                //trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdM_x_pI_store_GetF_Ack_AD__C__E) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(req2to_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                    out_msg.Type := CoherenceMessageType:MemClnEvct_IL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__E_evict);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                  //trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store_GetF_Ack_AD__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdM_x_pI_store_GetF_Ack_AD__C__M) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                    out_msg.Type := CoherenceMessageType:MemWr_IL2;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__M_evict);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                  //trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store_GetF_Ack_AD__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdM_x_pI_store_GetF_Ack_AD__C__S) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(req2to_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                    out_msg.Type := CoherenceMessageType:MemClnEvct_IL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__S_evict);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                  //trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store_GetF_Ack_AD__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdM_x_pI_store_GetM_Ack_AD__C__E) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(req2to_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                    out_msg.Type := CoherenceMessageType:MemClnEvct_IL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__E_evict);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                  //trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store_GetM_Ack_AD__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdM_x_pI_store_GetM_Ack_AD__C__M) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                    out_msg.Type := CoherenceMessageType:MemWr_IL2;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__M_evict);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                  //trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store_GetM_Ack_AD__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdM_x_pI_store_GetM_Ack_AD__C__S) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  enqueue(req2to_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                    out_msg.Type := CoherenceMessageType:MemClnEvct_IL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__S_evict);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                  //trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store_GetM_Ack_AD__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdM_x_pI_store__C__E) {
            if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID == getEntry(LineAddress).ownerL1) {
                enqueue(req2to_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                  out_msg.Type := CoherenceMessageType:MemClnEvct_IL2;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__E_evict);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                //trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store__C__E);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdM_x_pI_store__C__M) {
            if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID == getEntry(LineAddress).ownerL1) {
                enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                  out_msg.Type := CoherenceMessageType:MemWr_IL2;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__M_evict);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                //trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdM_x_pI_store__C__S) {
            if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID == getEntry(LineAddress).ownerL1) {
                enqueue(req2to_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                  out_msg.Type := CoherenceMessageType:MemClnEvct_IL2;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__S_evict);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                //trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else {
            trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
          }
        }
      }
    }
    
    in_port(reqfrom_in, CoherenceMessage, reqFrom, rank=5) {
      if (reqfrom_in.isReady(clockEdge())) {
        peek (reqfrom_in, CoherenceMessage, block_on="LineAddress") {
          Addr LineAddress := in_msg.LineAddress;
          TBE tbe := TBEs[LineAddress];
          State st := getState(tbe, getEntry(LineAddress), LineAddress);
          DPRINTF(RubySlicc, "reqfrom_in: %s %s %s (addr: %#x)\n", in_msg.Type, in_msg.Sender, st, LineAddress);
          // Start Evict handler
          if((st == State:I__C__I && in_msg.Type == CoherenceMessageType:GetML1) || (st == State:I__C__I && in_msg.Type == CoherenceMessageType:GetSL1)) {
            if (is_invalid(getEntry(LineAddress)) && cache.cacheAvail(LineAddress) == false ) {
              Addr victim := cache.cacheProbe(in_msg.LineAddress);
              DPRINTF(RubySlicc, "Evicting %#x (%s) for %#x\n", victim, getState(TBEs[victim], getEntry(victim), victim), LineAddress);
              Addr LineAddress := victim;
              TBE tbe := TBEs[LineAddress];
              Entry entry := getEntry(LineAddress);
              State st := getState(tbe, entry, LineAddress);
              if (st == State:E__C__M) {
                if (is_invalid(tbe)) {
                  if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                    trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                  } else {
                    DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                    reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                tbe.acksReceivedL1 := 0;
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                  out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                  out_msg.Sender := machineID;
                  out_msg.acksExpectedL1 := 0;
                }
                getEntry(LineAddress).ownerL1 := machineID;
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store__C__M);
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              } else if (st == State:F__C__E) {
                if (is_invalid(tbe)) {
                  if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                    trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                  } else {
                    DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                    reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                tbe.acksReceivedL1 := 0;
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID != getEntry(LineAddress).ownerL1) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                    out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                    out_msg.Sender := machineID;
                    out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                  }
                  if (getEntry(LineAddress).cacheL1.count() != 0) {
                    enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Control;
                      out_msg.Destination := getEntry(LineAddress).cacheL1;
                      out_msg.Type := CoherenceMessageType:InvL1;
                      out_msg.Sender := machineID;
                    }
                    getEntry(LineAddress).ownerL1 := machineID;
                    getEntry(LineAddress).cacheL1.clear();
                    setState(tbe, getEntry(LineAddress), LineAddress, State:evictdF_GetM_x_pI_store__C__E);
                  }
                  else if (getEntry(LineAddress).cacheL1.count() == 0) {
                    getEntry(LineAddress).ownerL1 := machineID;
                    getEntry(LineAddress).cacheL1.clear();
                    setState(tbe, getEntry(LineAddress), LineAddress, State:evictdF_GetM_x_pI_store__C__E);
                  }
                }
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              } else if (st == State:F__C__M) {
                if (is_invalid(tbe)) {
                  if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                    trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                  } else {
                    DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                    reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                tbe.acksReceivedL1 := 0;
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID != getEntry(LineAddress).ownerL1) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                    out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                    out_msg.Sender := machineID;
                    out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                  }
                  if (getEntry(LineAddress).cacheL1.count() != 0) {
                    enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Control;
                      out_msg.Destination := getEntry(LineAddress).cacheL1;
                      out_msg.Type := CoherenceMessageType:InvL1;
                      out_msg.Sender := machineID;
                    }
                    getEntry(LineAddress).ownerL1 := machineID;
                    getEntry(LineAddress).cacheL1.clear();
                    setState(tbe, getEntry(LineAddress), LineAddress, State:evictdF_GetM_x_pI_store__C__M);
                  }
                  else if (getEntry(LineAddress).cacheL1.count() == 0) {
                    getEntry(LineAddress).ownerL1 := machineID;
                    getEntry(LineAddress).cacheL1.clear();
                    setState(tbe, getEntry(LineAddress), LineAddress, State:evictdF_GetM_x_pI_store__C__M);
                  }
                }
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              } else if (st == State:F__C__S) {
                if (is_invalid(tbe)) {
                  if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                    trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                  } else {
                    DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                    reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                tbe.acksReceivedL1 := 0;
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID != getEntry(LineAddress).ownerL1) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                    out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                    out_msg.Sender := machineID;
                    out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                  }
                  if (getEntry(LineAddress).cacheL1.count() != 0) {
                    enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Control;
                      out_msg.Destination := getEntry(LineAddress).cacheL1;
                      out_msg.Type := CoherenceMessageType:InvL1;
                      out_msg.Sender := machineID;
                    }
                    getEntry(LineAddress).ownerL1 := machineID;
                    getEntry(LineAddress).cacheL1.clear();
                    setState(tbe, getEntry(LineAddress), LineAddress, State:evictdF_GetM_x_pI_store__C__S);
                  }
                  else if (getEntry(LineAddress).cacheL1.count() == 0) {
                    getEntry(LineAddress).ownerL1 := machineID;
                    getEntry(LineAddress).cacheL1.clear();
                    setState(tbe, getEntry(LineAddress), LineAddress, State:evictdF_GetM_x_pI_store__C__S);
                  }
                }
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              } else if (st == State:I__C__E) {
                if (is_invalid(tbe)) {
                  if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                    trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                  } else {
                    DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                    reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                tbe.acksReceivedL1 := 0;
                getEntry(LineAddress).cacheL1.clear();
                getEntry(LineAddress).ownerL1 := machineID;
                tbe.acksExpectedL1 := 0;
                if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                  getEntry(LineAddress).cacheL1.remove(machineID);
                  if (machineID == getEntry(LineAddress).ownerL1) {
                    enqueue(req2to_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Control;
                      out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                      out_msg.Type := CoherenceMessageType:MemClnEvct_IL2;
                      out_msg.Sender := machineID;
                    }
                    setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__E_evict);
                    trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              } else if (st == State:I__C__M) {
                if (is_invalid(tbe)) {
                  if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                    trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                  } else {
                    DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                    reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                tbe.acksReceivedL1 := 0;
                getEntry(LineAddress).cacheL1.clear();
                getEntry(LineAddress).ownerL1 := machineID;
                tbe.acksExpectedL1 := 0;
                if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                  getEntry(LineAddress).cacheL1.remove(machineID);
                  if (machineID == getEntry(LineAddress).ownerL1) {
                    enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Data;
                      out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                      out_msg.Type := CoherenceMessageType:MemWr_IL2;
                      out_msg.Sender := machineID;
                      out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                    }
                    setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__M_evict);
                    trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              } else if (st == State:I__C__S) {
                if (is_invalid(tbe)) {
                  if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                    trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                  } else {
                    DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                    reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                tbe.acksReceivedL1 := 0;
                getEntry(LineAddress).cacheL1.clear();
                getEntry(LineAddress).ownerL1 := machineID;
                tbe.acksExpectedL1 := 0;
                if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                  getEntry(LineAddress).cacheL1.remove(machineID);
                  if (machineID == getEntry(LineAddress).ownerL1) {
                    enqueue(req2to_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Control;
                      out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                      out_msg.Type := CoherenceMessageType:MemClnEvct_IL2;
                      out_msg.Sender := machineID;
                    }
                    setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__S_evict);
                    trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              } else if (st == State:M__C__M) {
                if (is_invalid(tbe)) {
                  if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                    trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                  } else {
                    DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                    reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                tbe.acksReceivedL1 := 0;
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                  out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                  out_msg.Sender := machineID;
                  out_msg.acksExpectedL1 := 0;
                }
                getEntry(LineAddress).ownerL1 := machineID;
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store__C__M);
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              } else if (st == State:S__C__E) {
                if (is_invalid(tbe)) {
                  if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                    trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                  } else {
                    DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                    reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                tbe.acksReceivedL1 := 0;
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := machineID;
                  }
                  getEntry(LineAddress).ownerL1 := machineID;
                  tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                  getEntry(LineAddress).cacheL1.clear();
                  if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                    getEntry(LineAddress).cacheL1.remove(machineID);
                    if (machineID == getEntry(LineAddress).ownerL1) {
                      enqueue(req2to_out, CoherenceMessage, responseLatency) {
                        out_msg.LineAddress := LineAddress;
                        out_msg.MessageSize := MessageSizeType:Control;
                        out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                        out_msg.Type := CoherenceMessageType:MemClnEvct_IL2;
                        out_msg.Sender := machineID;
                      }
                      setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__E_evict);
                      trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                    }
                  }
                  else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                    setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store_GetM_Ack_AD__C__E);
                  }
                }
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              } else if (st == State:S__C__M) {
                if (is_invalid(tbe)) {
                  if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                    trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                  } else {
                    DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                    reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                tbe.acksReceivedL1 := 0;
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := machineID;
                  }
                  getEntry(LineAddress).ownerL1 := machineID;
                  tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                  getEntry(LineAddress).cacheL1.clear();
                  if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                    getEntry(LineAddress).cacheL1.remove(machineID);
                    if (machineID == getEntry(LineAddress).ownerL1) {
                      enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                        out_msg.LineAddress := LineAddress;
                        out_msg.MessageSize := MessageSizeType:Data;
                        out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                        out_msg.Type := CoherenceMessageType:MemWr_IL2;
                        out_msg.Sender := machineID;
                        out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                      }
                      setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__M_evict);
                      trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                    }
                  }
                  else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                    setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store_GetM_Ack_AD__C__M);
                  }
                }
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              } else if (st == State:S__C__S) {
                if (is_invalid(tbe)) {
                  if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                    trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                  } else {
                    DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                    reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                tbe.acksReceivedL1 := 0;
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := machineID;
                  }
                  getEntry(LineAddress).ownerL1 := machineID;
                  tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                  getEntry(LineAddress).cacheL1.clear();
                  if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                    getEntry(LineAddress).cacheL1.remove(machineID);
                    if (machineID == getEntry(LineAddress).ownerL1) {
                      enqueue(req2to_out, CoherenceMessage, responseLatency) {
                        out_msg.LineAddress := LineAddress;
                        out_msg.MessageSize := MessageSizeType:Control;
                        out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                        out_msg.Type := CoherenceMessageType:MemClnEvct_IL2;
                        out_msg.Sender := machineID;
                      }
                      setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__S_evict);
                      trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                    }
                  }
                  else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                    setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store_GetM_Ack_AD__C__S);
                  }
                }
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              } else {
                DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            }
          }
          // End Evict Handler
          if (st == State:E__C__M) {
            if (in_msg.Type == CoherenceMessageType:GetML1) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              //tbe.proxy_msgL1_exclusiveL1 := in_msg.exclusiveL1;
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                out_msg.acksExpectedL1 := 0;
              }
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:GetSL1) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                  reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              //tbe.proxy_msgL1_exclusiveL1 := in_msg.exclusiveL1;
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                out_msg.Type := CoherenceMessageType:Fwd_GetSL1;
                out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
              }
              getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).ownerL1);
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1E_GetS__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutEL1) {
              getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
              if (in_msg.Sender == getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutE_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (in_msg.Sender != getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:E__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutFL1) {
              getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
              if (in_msg.Sender == getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutE_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (in_msg.Sender != getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:E__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutIL1) {
              getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
              if (in_msg.Sender == getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutE_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (in_msg.Sender != getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:E__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutML1) {
              getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
              if (in_msg.Sender != getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:E__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (in_msg.Sender == getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutM_AckL1;
                  out_msg.Sender := machineID;
                }
                setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutSL1) {
              getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
              if (in_msg.Sender == getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutE_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (in_msg.Sender != getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:E__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:F__C__E) {
            if (in_msg.Type == CoherenceMessageType:GetML1) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                  reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              //tbe.proxy_msgL1_exclusiveL1 := in_msg.exclusiveL1;
              getEntry(LineAddress).cacheL1.remove(getEntry(LineAddress).proxy_msgL1_src);
              if (getEntry(LineAddress).proxy_msgL1_src == getEntry(LineAddress).ownerL1) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                  out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                }
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                  }
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  cache.setMRU(LineAddress);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() == 0) {
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  cache.setMRU(LineAddress);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).proxy_msgL1_src != getEntry(LineAddress).ownerL1) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                  out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                  out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                  out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                }
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                  }
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  cache.setMRU(LineAddress);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() == 0) {
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  cache.setMRU(LineAddress);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else if (in_msg.Type == CoherenceMessageType:GetSL1) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                  reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              //tbe.proxy_msgL1_exclusiveL1 := in_msg.exclusiveL1;
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                out_msg.Type := CoherenceMessageType:Fwd_GetSL1;
                out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
              }
              getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).ownerL1);
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1F_GetS__C__E);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutEL1) {
              if (in_msg.Sender == getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutF_AckL1;
                  out_msg.Sender := machineID;
                }
                setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (in_msg.Sender != getEntry(LineAddress).ownerL1) {
                if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              }
            } else if (in_msg.Type == CoherenceMessageType:PutFL1) {
              if (getEntry(LineAddress).ownerL1 == in_msg.Sender) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutF_AckL1;
                  out_msg.Sender := machineID;
                }
                setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).ownerL1 != in_msg.Sender) {
                if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              }
            } else if (in_msg.Type == CoherenceMessageType:PutIL1) {
              if (getEntry(LineAddress).ownerL1 == in_msg.Sender) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutF_AckL1;
                  out_msg.Sender := machineID;
                }
                setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).ownerL1 != in_msg.Sender) {
                if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              }
            } else if (in_msg.Type == CoherenceMessageType:PutML1) {
              if (in_msg.Sender == getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutF_AckL1;
                  out_msg.Sender := machineID;
                }
                setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (in_msg.Sender != getEntry(LineAddress).ownerL1) {
                if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              }
            } else if (in_msg.Type == CoherenceMessageType:PutSL1) {
              if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) != false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:F__C__M) {
            if (in_msg.Type == CoherenceMessageType:GetML1) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                  reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              //tbe.proxy_msgL1_exclusiveL1 := in_msg.exclusiveL1;
              getEntry(LineAddress).cacheL1.remove(getEntry(LineAddress).proxy_msgL1_src);
              if (getEntry(LineAddress).proxy_msgL1_src == getEntry(LineAddress).ownerL1) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                  out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                }
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                  }
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  cache.setMRU(LineAddress);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() == 0) {
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  cache.setMRU(LineAddress);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).proxy_msgL1_src != getEntry(LineAddress).ownerL1) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                  out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                  out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                  out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                }
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                  }
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  cache.setMRU(LineAddress);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() == 0) {
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  cache.setMRU(LineAddress);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else if (in_msg.Type == CoherenceMessageType:GetSL1) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                  reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              //tbe.proxy_msgL1_exclusiveL1 := in_msg.exclusiveL1;
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                out_msg.Type := CoherenceMessageType:Fwd_GetSL1;
                out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
              }
              getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).ownerL1);
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1F_GetS__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutEL1) {
              if (in_msg.Sender == getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutF_AckL1;
                  out_msg.Sender := machineID;
                }
                setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (in_msg.Sender != getEntry(LineAddress).ownerL1) {
                if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              }
            } else if (in_msg.Type == CoherenceMessageType:PutFL1) {
              if (getEntry(LineAddress).ownerL1 == in_msg.Sender) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutF_AckL1;
                  out_msg.Sender := machineID;
                }
                setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).ownerL1 != in_msg.Sender) {
                if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              }
            } else if (in_msg.Type == CoherenceMessageType:PutIL1) {
              if (getEntry(LineAddress).ownerL1 == in_msg.Sender) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutF_AckL1;
                  out_msg.Sender := machineID;
                }
                setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).ownerL1 != in_msg.Sender) {
                if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              }
            } else if (in_msg.Type == CoherenceMessageType:PutML1) {
              if (in_msg.Sender == getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutF_AckL1;
                  out_msg.Sender := machineID;
                }
                setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (in_msg.Sender != getEntry(LineAddress).ownerL1) {
                if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              }
            } else if (in_msg.Type == CoherenceMessageType:PutSL1) {
              if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) != false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:F__C__S) {
            if (in_msg.Type == CoherenceMessageType:GetML1) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                  reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              enqueue(req2to_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                out_msg.Type := CoherenceMessageType:MemInv_A_SnpInvL2;
                out_msg.Sender := machineID;
              }
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              //tbe.proxy_msgL1_exclusiveL1 := in_msg.exclusiveL1;
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F__C__S_store);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:GetSL1) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                  reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              //tbe.proxy_msgL1_exclusiveL1 := in_msg.exclusiveL1;
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                out_msg.Type := CoherenceMessageType:Fwd_GetSL1;
                out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
              }
              getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).ownerL1);
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1F_GetS__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutEL1) {
              if (in_msg.Sender == getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutF_AckL1;
                  out_msg.Sender := machineID;
                }
                setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (in_msg.Sender != getEntry(LineAddress).ownerL1) {
                if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              }
            } else if (in_msg.Type == CoherenceMessageType:PutFL1) {
              if (getEntry(LineAddress).ownerL1 == in_msg.Sender) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutF_AckL1;
                  out_msg.Sender := machineID;
                }
                setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).ownerL1 != in_msg.Sender) {
                if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              }
            } else if (in_msg.Type == CoherenceMessageType:PutIL1) {
              if (getEntry(LineAddress).ownerL1 == in_msg.Sender) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutF_AckL1;
                  out_msg.Sender := machineID;
                }
                setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).ownerL1 != in_msg.Sender) {
                if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              }
            } else if (in_msg.Type == CoherenceMessageType:PutML1) {
              if (in_msg.Sender == getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutF_AckL1;
                  out_msg.Sender := machineID;
                }
                setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (in_msg.Sender != getEntry(LineAddress).ownerL1) {
                if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              }
            } else if (in_msg.Type == CoherenceMessageType:PutSL1) {
              if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) != false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:I__C__E) {
            if (in_msg.Type == CoherenceMessageType:GetML1) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              //tbe.proxy_msgL1_exclusiveL1 := in_msg.exclusiveL1;
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                out_msg.acksExpectedL1 := 0;
              }
              getEntry(LineAddress).cacheL1.clear();
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:GetSL1) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              if (in_msg.exclusiveL1) {
              //tbe.proxy_msgL1_exclusiveL1 := in_msg.exclusiveL1;
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetM_Ack_DL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
              }
              getEntry(LineAddress).cacheL1.clear();
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:E__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (in_msg.exclusiveL1 == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                  //out_msg.Type := CoherenceMessageType:GetF_AckL1;
                  out_msg.Type := CoherenceMessageType:GetS_AckL1;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                }
                //getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).proxy_msgL1_src);
                cache.setMRU(LineAddress);
                //setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__E);
                setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutEL1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__E);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutFL1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__E);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutIL1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__E);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutML1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__E);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutSL1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__E);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:I__C__I) {
            if (in_msg.Type == CoherenceMessageType:GetML1) {
              if (is_invalid(getEntry(LineAddress))) {
                trigger(Event:allocCacheEntry, LineAddress, getEntry(LineAddress), tbe);
              }
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                  reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              enqueue(req2to_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                out_msg.Type := CoherenceMessageType:MemRd_A_SnpInvL2;
                out_msg.Sender := machineID;
              }
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              //tbe.proxy_msgL1_exclusiveL1 := in_msg.exclusiveL1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1I__C__I_store);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:GetSL1) {
              if (is_invalid(getEntry(LineAddress))) {
                trigger(Event:allocCacheEntry, LineAddress, getEntry(LineAddress), tbe);
              }
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                  reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              tbe.proxy_msgL1_exclusiveL1 := in_msg.exclusiveL1;
              enqueue(req2to_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                //out_msg.Type := CoherenceMessageType:MemRd_A_SnpInvL2;
                out_msg.Type := CoherenceMessageType:MemRd_S_SnpDataL2;
                out_msg.Sender := machineID;
                //out_msg.exclusiveL1 := true;
                //out_msg.exclusiveL1 := false;
                out_msg.exclusiveL1 := in_msg.exclusiveL1;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1I__C__I_store);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutEL1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              //trigger(Event:deallocreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutFL1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              //trigger(Event:deallocreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutIL1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              //trigger(Event:deallocreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutML1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              //trigger(Event:deallocreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutSL1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              //trigger(Event:deallocreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:I__C__M) {
            if (in_msg.Type == CoherenceMessageType:GetML1) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              //tbe.proxy_msgL1_exclusiveL1 := in_msg.exclusiveL1;
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                out_msg.acksExpectedL1 := 0;
              }
              getEntry(LineAddress).cacheL1.clear();
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:GetSL1) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              //tbe.proxy_msgL1_exclusiveL1 := in_msg.exclusiveL1;
              if (in_msg.exclusiveL1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetM_Ack_DL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
              }
              getEntry(LineAddress).cacheL1.clear();
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:E__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (in_msg.exclusiveL1 == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                  //out_msg.Type := CoherenceMessageType:GetF_AckL1;
                  out_msg.Type := CoherenceMessageType:GetS_AckL1;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                }
                //getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).proxy_msgL1_src);
                cache.setMRU(LineAddress);
                //setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__M);
                setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutEL1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutFL1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutIL1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutML1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutSL1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:I__C__S) {
            if (in_msg.Type == CoherenceMessageType:GetML1) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                  reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              enqueue(req2to_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                out_msg.Type := CoherenceMessageType:MemInv_A_SnpInvL2;
                out_msg.Sender := machineID;
              }
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              //tbe.proxy_msgL1_exclusiveL1 := in_msg.exclusiveL1;
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1I__C__S_store);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:GetSL1) {
              if (in_msg.exclusiveL1) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                  out_msg.Type := CoherenceMessageType:GetS_AckL1;
                  //out_msg.Type := CoherenceMessageType:GetF_AckL1;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                }
                //getEntry(LineAddress).cacheL1.clear();
                //getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).proxy_msgL1_src);
                cache.setMRU(LineAddress);
                setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
                // NOTE: we don't go to F__C__S, on first sharing request (termintation problem)
                //setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (in_msg.exclusiveL1 == false) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                  //out_msg.Type := CoherenceMessageType:GetF_AckL1;
                  out_msg.Type := CoherenceMessageType:GetS_AckL1;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                }
                getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).proxy_msgL1_src);
                //getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                //getEntry(LineAddress).cacheL1.clear();
                cache.setMRU(LineAddress);
                //setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__S);
                setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              //if (is_invalid(tbe)) {
              //  if (TBEs.areNSlotsAvailable(1, clockEdge())) {
              //    trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
              //  } else {
              //    DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
              //    reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
              //    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              //  }
              //}
              //enqueue(req2to_out, CoherenceMessage, responseLatency) {
              //  out_msg.LineAddress := LineAddress;
              //  out_msg.MessageSize := MessageSizeType:Control;
              //  out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
              //  out_msg.Type := CoherenceMessageType:MemInv_A_SnpInvL2;
              //  out_msg.Sender := machineID;
              //}
              //getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              ////tbe.proxy_msgL1_exclusiveL1 := in_msg.exclusiveL1;
              //cache.setMRU(LineAddress);
              //setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1I__C__S_store);
              //DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              //reqfrom_in.dequeue(clockEdge());
              //trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutEL1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutFL1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutIL1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutML1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutSL1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:M__C__M) {
            if (in_msg.Type == CoherenceMessageType:GetML1) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              //tbe.proxy_msgL1_exclusiveL1 := in_msg.exclusiveL1;
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                out_msg.acksExpectedL1 := 0;
              }
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:GetSL1) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                  reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              //tbe.proxy_msgL1_exclusiveL1 := in_msg.exclusiveL1;
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                out_msg.Type := CoherenceMessageType:Fwd_GetSL1;
                out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
              }
              getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).ownerL1);
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1M_GetS__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutEL1) {
              getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
              if (in_msg.Sender != getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (in_msg.Sender == getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutM_AckL1;
                  out_msg.Sender := machineID;
                }
                setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutFL1) {
              getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
              if (in_msg.Sender != getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (in_msg.Sender == getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutM_AckL1;
                  out_msg.Sender := machineID;
                }
                setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutIL1) {
              getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
              if (in_msg.Sender != getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (in_msg.Sender == getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutM_AckL1;
                  out_msg.Sender := machineID;
                }
                setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutML1) {
              getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
              if (in_msg.Sender != getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (in_msg.Sender == getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutM_AckL1;
                  out_msg.Sender := machineID;
                }
                setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutSL1) {
              getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
              if (in_msg.Sender == getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutM_AckL1;
                  out_msg.Sender := machineID;
                }
                setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (in_msg.Sender != getEntry(LineAddress).ownerL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:S__C__E) {
            if (in_msg.Type == CoherenceMessageType:GetML1) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              //tbe.proxy_msgL1_exclusiveL1 := in_msg.exclusiveL1;
              getEntry(LineAddress).cacheL1.remove(getEntry(LineAddress).proxy_msgL1_src);
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
              }
              if (getEntry(LineAddress).cacheL1.count() != 0) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1;
                  out_msg.Type := CoherenceMessageType:InvL1;
                  out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                }
                getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                getEntry(LineAddress).cacheL1.clear();
                cache.setMRU(LineAddress);
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).cacheL1.count() == 0) {
                getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                getEntry(LineAddress).cacheL1.clear();
                cache.setMRU(LineAddress);
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:GetSL1) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              //tbe.proxy_msgL1_exclusiveL1 := in_msg.exclusiveL1;
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetF_AckL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
              }
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__E);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutEL1) {
              if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutFL1) {
              if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutIL1) {
              if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutML1) {
              if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutSL1) {
              if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__E);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:S__C__M) {
            if (in_msg.Type == CoherenceMessageType:GetML1) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              //tbe.proxy_msgL1_exclusiveL1 := in_msg.exclusiveL1;
              getEntry(LineAddress).cacheL1.remove(getEntry(LineAddress).proxy_msgL1_src);
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
              }
              if (getEntry(LineAddress).cacheL1.count() != 0) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1;
                  out_msg.Type := CoherenceMessageType:InvL1;
                  out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                }
                getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                getEntry(LineAddress).cacheL1.clear();
                cache.setMRU(LineAddress);
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).cacheL1.count() == 0) {
                getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                getEntry(LineAddress).cacheL1.clear();
                cache.setMRU(LineAddress);
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:GetSL1) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              //tbe.proxy_msgL1_exclusiveL1 := in_msg.exclusiveL1;
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetF_AckL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
              }
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutEL1) {
              if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutFL1) {
              if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutIL1) {
              if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutML1) {
              if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutSL1) {
              if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:S__C__S) {
            if (in_msg.Type == CoherenceMessageType:GetML1) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                  reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              enqueue(req2to_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                out_msg.Type := CoherenceMessageType:MemInv_A_SnpInvL2;
                out_msg.Sender := machineID;
              }
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              //tbe.proxy_msgL1_exclusiveL1 := in_msg.exclusiveL1;
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1S__C__S_store);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:GetSL1) {
              if (in_msg.exclusiveL1) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              //tbe.proxy_msgL1_exclusiveL1 := in_msg.exclusiveL1;
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetF_AckL1;
                //out_msg.Type := CoherenceMessageType:GetS_AckL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
              }
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              //getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).proxy_msgL1_src);
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__S);
              //setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (in_msg.exclusiveL1 == false) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              //tbe.proxy_msgL1_exclusiveL1 := in_msg.exclusiveL1;
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                //out_msg.Type := CoherenceMessageType:GetF_AckL1;
                out_msg.Type := CoherenceMessageType:GetS_AckL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
              }
              //getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).proxy_msgL1_src);
              cache.setMRU(LineAddress);
              //setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__S);
              setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutEL1) {
              if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutFL1) {
              if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutIL1) {
              if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutML1) {
              if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutSL1) {
              if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else {
            trigger(Event:Stallreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
          }
        }
      }
    }
    
    in_port(drsfrom_in, CoherenceMessage, drsFrom, rank=3) {
      if (drsfrom_in.isReady(clockEdge())) {
        peek (drsfrom_in, CoherenceMessage, block_on="LineAddress") {
          Addr LineAddress := in_msg.LineAddress;
          TBE tbe := TBEs[LineAddress];
          State st := getState(tbe, getEntry(LineAddress), LineAddress);
          DPRINTF(RubySlicc, "drsfrom_in: %s %s %s (addr: %#x)\n", in_msg.Type, in_msg.Sender, st, LineAddress);
          if (st == State:GetML1F__C__I_store_Cmp_E) {
            if (in_msg.Type == CoherenceMessageType:MemDataL2) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              getEntry(LineAddress).cacheL1.remove(getEntry(LineAddress).proxy_msgL1_src);
              if (getEntry(LineAddress).proxy_msgL1_src == getEntry(LineAddress).ownerL1) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                  out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                }
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                  }
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on drsfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  drsfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() == 0) {
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on drsfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  drsfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).proxy_msgL1_src != getEntry(LineAddress).ownerL1) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                  out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                  out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                  out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                }
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                  }
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on drsfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  drsfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() == 0) {
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F_GetM__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on drsfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  drsfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else {
              trigger(Event:Stalldrsfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetML1I__C__I_store_Cmp_E) {
            if (in_msg.Type == CoherenceMessageType:MemDataL2) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                out_msg.acksExpectedL1 := 0;
              }
              getEntry(LineAddress).cacheL1.clear();
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on drsfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              drsfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stalldrsfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetML1S__C__I_store_Cmp_E) {
            if (in_msg.Type == CoherenceMessageType:MemDataL2) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              getEntry(LineAddress).cacheL1.remove(getEntry(LineAddress).proxy_msgL1_src);
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
              }
              if (getEntry(LineAddress).cacheL1.count() != 0) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1;
                  out_msg.Type := CoherenceMessageType:InvL1;
                  out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                }
                getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                getEntry(LineAddress).cacheL1.clear();
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on drsfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                drsfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).cacheL1.count() == 0) {
                getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                getEntry(LineAddress).cacheL1.clear();
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on drsfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                drsfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stalldrsfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetSL1I__C__I_store_Cmp_E) {
            if (in_msg.Type == CoherenceMessageType:MemDataL2) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              if (tbe.proxy_msgL1_exclusiveL1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetM_Ack_DL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
              }
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              getEntry(LineAddress).cacheL1.clear();
              tbe.proxy_msgL1_exclusiveL1 := false;
              setState(tbe, getEntry(LineAddress), LineAddress, State:E__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on drsfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              drsfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.proxy_msgL1_exclusiveL1 == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                  //out_msg.Type := CoherenceMessageType:GetF_AckL1;
                  out_msg.Type := CoherenceMessageType:GetS_AckL1;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                }
                //getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).proxy_msgL1_src);
                //setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__E);
                setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__E);
                tbe.proxy_msgL1_exclusiveL1 := false;
                DPRINTF(RubySlicc, "Popping %s %s on drsfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                drsfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stalldrsfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetSL1I__C__I_store_Cmp_S) {
            if (in_msg.Type == CoherenceMessageType:MemDataL2) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              if (tbe.proxy_msgL1_exclusiveL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                  out_msg.Type := CoherenceMessageType:GetS_AckL1;
                  //out_msg.Type := CoherenceMessageType:GetF_AckL1;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                }
                getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).proxy_msgL1_src);
                //getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
                // NOTE: we don't go to F__C__S, on first sharing request (termintation problem)
                //setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__S);
                tbe.proxy_msgL1_exclusiveL1 := false;
                DPRINTF(RubySlicc, "Popping %s %s on drsfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                drsfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.proxy_msgL1_exclusiveL1 == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                  //out_msg.Type := CoherenceMessageType:GetF_AckL1;
                  out_msg.Type := CoherenceMessageType:GetS_AckL1;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                }
                //getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).proxy_msgL1_src);
                //setState(tbe, getEntry(LineAddress), LineAddress, State:F__C__S);
                setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
                tbe.proxy_msgL1_exclusiveL1 := false;
                DPRINTF(RubySlicc, "Popping %s %s on drsfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                drsfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stalldrsfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else {
            trigger(Event:Stalldrsfrom_in, LineAddress, getEntry(LineAddress), tbe);
          }
        }
      }
    }
    
    in_port(bisnpfrom_in, CoherenceMessage, bisnpFrom, rank=4) {
      if (bisnpfrom_in.isReady(clockEdge())) {
        peek (bisnpfrom_in, CoherenceMessage, block_on="LineAddress") {
          Addr LineAddress := in_msg.LineAddress;
          TBE tbe := TBEs[LineAddress];
          State st := getState(tbe, getEntry(LineAddress), LineAddress);
          DPRINTF(RubySlicc, "bisnpfrom_in: %s %s %s (addr: %#x)\n", in_msg.Type, in_msg.Sender, st, LineAddress);
          if (st == State:E__C__M) {
            if (in_msg.Type == CoherenceMessageType:BISnpDataL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on bisnpfrom_in (addr: %#x)\n", st, LineAddress);
                  bisnpfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                out_msg.Sender := machineID;
                out_msg.acksExpectedL1 := 0;
              }
              getEntry(LineAddress).ownerL1 := machineID;
              getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dM_x_pI_store__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:BISnpInvL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on bisnpfrom_in (addr: %#x)\n", st, LineAddress);
                  bisnpfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                out_msg.Sender := machineID;
                out_msg.acksExpectedL1 := 0;
              }
              getEntry(LineAddress).ownerL1 := machineID;
              getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dM_x_pI_store__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:F__C__E) {
            if (in_msg.Type == CoherenceMessageType:BISnpDataL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on bisnpfrom_in (addr: %#x)\n", st, LineAddress);
                  bisnpfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID != getEntry(LineAddress).ownerL1) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                  out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                  out_msg.Sender := machineID;
                  out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                }
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := machineID;
                  }
                  getEntry(LineAddress).ownerL1 := machineID;
                  getEntry(LineAddress).cacheL1.clear();
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dF_GetM_x_pI_store__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  bisnpfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() == 0) {
                  getEntry(LineAddress).ownerL1 := machineID;
                  getEntry(LineAddress).cacheL1.clear();
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dF_GetM_x_pI_store__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  bisnpfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else if (in_msg.Type == CoherenceMessageType:BISnpInvL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on bisnpfrom_in (addr: %#x)\n", st, LineAddress);
                  bisnpfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID != getEntry(LineAddress).ownerL1) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                  out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                  out_msg.Sender := machineID;
                  out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                }
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := machineID;
                  }
                  getEntry(LineAddress).ownerL1 := machineID;
                  getEntry(LineAddress).cacheL1.clear();
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dF_GetM_x_pI_store__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  bisnpfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() == 0) {
                  getEntry(LineAddress).ownerL1 := machineID;
                  getEntry(LineAddress).cacheL1.clear();
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dF_GetM_x_pI_store__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  bisnpfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else {
              trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:F__C__M) {
            if (in_msg.Type == CoherenceMessageType:BISnpDataL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on bisnpfrom_in (addr: %#x)\n", st, LineAddress);
                  bisnpfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID != getEntry(LineAddress).ownerL1) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                  out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                  out_msg.Sender := machineID;
                  out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                }
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := machineID;
                  }
                  getEntry(LineAddress).ownerL1 := machineID;
                  getEntry(LineAddress).cacheL1.clear();
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dF_GetM_x_pI_store__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  bisnpfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() == 0) {
                  getEntry(LineAddress).ownerL1 := machineID;
                  getEntry(LineAddress).cacheL1.clear();
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dF_GetM_x_pI_store__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  bisnpfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else if (in_msg.Type == CoherenceMessageType:BISnpInvL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on bisnpfrom_in (addr: %#x)\n", st, LineAddress);
                  bisnpfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID != getEntry(LineAddress).ownerL1) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                  out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                  out_msg.Sender := machineID;
                  out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                }
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := machineID;
                  }
                  getEntry(LineAddress).ownerL1 := machineID;
                  getEntry(LineAddress).cacheL1.clear();
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dF_GetM_x_pI_store__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  bisnpfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() == 0) {
                  getEntry(LineAddress).ownerL1 := machineID;
                  getEntry(LineAddress).cacheL1.clear();
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dF_GetM_x_pI_store__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  bisnpfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else {
              trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:F__C__S) {
            if (in_msg.Type == CoherenceMessageType:BISnpDataL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on bisnpfrom_in (addr: %#x)\n", st, LineAddress);
                  bisnpfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID != getEntry(LineAddress).ownerL1) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                  out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                  out_msg.Sender := machineID;
                  out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                }
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := machineID;
                  }
                  getEntry(LineAddress).ownerL1 := machineID;
                  getEntry(LineAddress).cacheL1.clear();
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dF_GetM_x_pI_store__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  bisnpfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() == 0) {
                  getEntry(LineAddress).ownerL1 := machineID;
                  getEntry(LineAddress).cacheL1.clear();
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dF_GetM_x_pI_store__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  bisnpfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else if (in_msg.Type == CoherenceMessageType:BISnpInvL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on bisnpfrom_in (addr: %#x)\n", st, LineAddress);
                  bisnpfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (machineID != getEntry(LineAddress).ownerL1) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                  out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                  out_msg.Sender := machineID;
                  out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                }
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := machineID;
                  }
                  getEntry(LineAddress).ownerL1 := machineID;
                  getEntry(LineAddress).cacheL1.clear();
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dF_GetM_x_pI_store__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  bisnpfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() == 0) {
                  getEntry(LineAddress).ownerL1 := machineID;
                  getEntry(LineAddress).cacheL1.clear();
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dF_GetM_x_pI_store__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  bisnpfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else {
              trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetML1F__C__I_store) {
            if (in_msg.Type == CoherenceMessageType:BISnpDataL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F__C__I_store);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:BISnpInvL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F__C__I_store);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetML1F__C__S_store) {
            if (in_msg.Type == CoherenceMessageType:BISnpDataL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F__C__S_store);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:BISnpInvL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1F__C__S_store);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetML1I__C__I_store) {
            if (in_msg.Type == CoherenceMessageType:BISnpDataL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1I__C__I_store);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:BISnpInvL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1I__C__I_store);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetML1I__C__S_store) {
            if (in_msg.Type == CoherenceMessageType:BISnpDataL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1I__C__S_store);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:BISnpInvL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1I__C__S_store);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetML1S__C__I_store) {
            if (in_msg.Type == CoherenceMessageType:BISnpDataL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1S__C__I_store);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:BISnpInvL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1S__C__I_store);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetML1S__C__S_store) {
            if (in_msg.Type == CoherenceMessageType:BISnpDataL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1S__C__S_store);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:BISnpInvL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1S__C__S_store);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetSL1I__C__I_store) {
            if (in_msg.Type == CoherenceMessageType:BISnpDataL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1I__C__I_store);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:BISnpInvL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1I__C__I_store);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetSL1I__C__S_store) {
            if (in_msg.Type == CoherenceMessageType:BISnpDataL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1I__C__S_store);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:BISnpInvL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1I__C__S_store);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:I__C__E) {
            if (in_msg.Type == CoherenceMessageType:BISnpDataL2) {
              //tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.clear();
              getEntry(LineAddress).ownerL1 := machineID;
              //tbe.acksExpectedL1 := 0;
              //if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspSL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  bisnpfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              //}
            } else if (in_msg.Type == CoherenceMessageType:BISnpInvL2) {
              //tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.clear();
              getEntry(LineAddress).ownerL1 := machineID;
              //tbe.acksExpectedL1 := 0;
              //if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspIL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                  trigger(Event:deallocbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
                }
              //}
            } else {
              trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:I__C__I) {
            if (in_msg.Type == CoherenceMessageType:BISnpDataL2) {
              enqueue(birspto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIRspIL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              //trigger(Event:deallocbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:BISnpInvL2) {
              //tbe.acksReceivedL1 := 0;
              //getEntry(LineAddress).cacheL1.clear();
              //getEntry(LineAddress).ownerL1 := machineID;
              //tbe.acksExpectedL1 := 0;
              //if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
              //  getEntry(LineAddress).cacheL1.remove(machineID);
              //  if (machineID == getEntry(LineAddress).ownerL1) {
              //    getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
              //      out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Destination.add(in_msg.Sender);
                    out_msg.Type := CoherenceMessageType:BIRspIL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                  bisnpfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              //    trigger(Event:deallocbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
              //  }
              //}
            } else {
              trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:I__C__M) {
            if (in_msg.Type == CoherenceMessageType:BISnpDataL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on bisnpfrom_in (addr: %#x)\n", st, LineAddress);
                  bisnpfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.clear();
              getEntry(LineAddress).ownerL1 := machineID;
              tbe.acksExpectedL1 := 0;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:MemWr_SL2;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2I__C__M_BISnpData);
                  DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  bisnpfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else if (in_msg.Type == CoherenceMessageType:BISnpInvL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on bisnpfrom_in (addr: %#x)\n", st, LineAddress);
                  bisnpfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.clear();
              getEntry(LineAddress).ownerL1 := machineID;
              tbe.acksExpectedL1 := 0;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:MemWr_IL2;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2I__C__M_BISnpInv);
                  DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  bisnpfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else {
              trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:I__C__S) {
            if (in_msg.Type == CoherenceMessageType:BISnpDataL2) {
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.clear();
              getEntry(LineAddress).ownerL1 := machineID;
              tbe.acksExpectedL1 := 0;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspSL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  bisnpfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else if (in_msg.Type == CoherenceMessageType:BISnpInvL2) {
              //tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.clear();
              getEntry(LineAddress).ownerL1 := machineID;
              //tbe.acksExpectedL1 := 0;
              //if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (machineID == getEntry(LineAddress).ownerL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  enqueue(birspto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:BIRspIL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                  trigger(Event:deallocbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
                }
              //}
            } else {
              trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:M__C__M) {
            if (in_msg.Type == CoherenceMessageType:BISnpDataL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on bisnpfrom_in (addr: %#x)\n", st, LineAddress);
                  bisnpfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                out_msg.Sender := machineID;
                out_msg.acksExpectedL1 := 0;
              }
              getEntry(LineAddress).ownerL1 := machineID;
              getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dM_x_pI_store__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:BISnpInvL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on bisnpfrom_in (addr: %#x)\n", st, LineAddress);
                  bisnpfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                out_msg.Sender := machineID;
                out_msg.acksExpectedL1 := 0;
              }
              getEntry(LineAddress).ownerL1 := machineID;
              getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
              setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dM_x_pI_store__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:S__C__E) {
            if (in_msg.Type == CoherenceMessageType:BISnpDataL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on bisnpfrom_in (addr: %#x)\n", st, LineAddress);
                  bisnpfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (getEntry(LineAddress).cacheL1.count() != 0) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1;
                  out_msg.Type := CoherenceMessageType:InvL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).ownerL1 := machineID;
                tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                getEntry(LineAddress).cacheL1.clear();
                if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                  getEntry(LineAddress).cacheL1.remove(machineID);
                  if (machineID == getEntry(LineAddress).ownerL1) {
                    getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                    enqueue(birspto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Control;
                      out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                      out_msg.Type := CoherenceMessageType:BIRspSL2;
                      out_msg.Sender := machineID;
                    }
                    setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                    DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                    bisnpfrom_in.dequeue(clockEdge());
                    trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  bisnpfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else if (in_msg.Type == CoherenceMessageType:BISnpInvL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on bisnpfrom_in (addr: %#x)\n", st, LineAddress);
                  bisnpfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (getEntry(LineAddress).cacheL1.count() != 0) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1;
                  out_msg.Type := CoherenceMessageType:InvL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).ownerL1 := machineID;
                tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                getEntry(LineAddress).cacheL1.clear();
                if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                  getEntry(LineAddress).cacheL1.remove(machineID);
                  if (machineID == getEntry(LineAddress).ownerL1) {
                    getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                    enqueue(birspto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Control;
                      out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                      out_msg.Type := CoherenceMessageType:BIRspIL2;
                      out_msg.Sender := machineID;
                    }
                    setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                    trigger(Event:deallocbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__E);
                  DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  bisnpfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else {
              trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:S__C__M) {
            if (in_msg.Type == CoherenceMessageType:BISnpDataL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on bisnpfrom_in (addr: %#x)\n", st, LineAddress);
                  bisnpfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (getEntry(LineAddress).cacheL1.count() != 0) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1;
                  out_msg.Type := CoherenceMessageType:InvL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).ownerL1 := machineID;
                tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                getEntry(LineAddress).cacheL1.clear();
                if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                  getEntry(LineAddress).cacheL1.remove(machineID);
                  if (machineID == getEntry(LineAddress).ownerL1) {
                    getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                    enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Data;
                      out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                      out_msg.Type := CoherenceMessageType:MemWr_SL2;
                      out_msg.Sender := machineID;
                      out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                    }
                    setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2I__C__M_BISnpData);
                    DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                    bisnpfrom_in.dequeue(clockEdge());
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  bisnpfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else if (in_msg.Type == CoherenceMessageType:BISnpInvL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on bisnpfrom_in (addr: %#x)\n", st, LineAddress);
                  bisnpfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (getEntry(LineAddress).cacheL1.count() != 0) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1;
                  out_msg.Type := CoherenceMessageType:InvL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).ownerL1 := machineID;
                tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                getEntry(LineAddress).cacheL1.clear();
                if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                  getEntry(LineAddress).cacheL1.remove(machineID);
                  if (machineID == getEntry(LineAddress).ownerL1) {
                    getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                    enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Data;
                      out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                      out_msg.Type := CoherenceMessageType:MemWr_IL2;
                      out_msg.Sender := machineID;
                      out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                    }
                    setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2I__C__M_BISnpInv);
                    DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                    bisnpfrom_in.dequeue(clockEdge());
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  bisnpfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else {
              trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:S__C__S) {
            if (in_msg.Type == CoherenceMessageType:BISnpDataL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on bisnpfrom_in (addr: %#x)\n", st, LineAddress);
                  bisnpfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (getEntry(LineAddress).cacheL1.count() != 0) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1;
                  out_msg.Type := CoherenceMessageType:InvL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).ownerL1 := machineID;
                tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                getEntry(LineAddress).cacheL1.clear();
                if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                  getEntry(LineAddress).cacheL1.remove(machineID);
                  if (machineID == getEntry(LineAddress).ownerL1) {
                    getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                    enqueue(birspto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Control;
                      out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                      out_msg.Type := CoherenceMessageType:BIRspSL2;
                      out_msg.Sender := machineID;
                    }
                    setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                    DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                    bisnpfrom_in.dequeue(clockEdge());
                    trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  bisnpfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else if (in_msg.Type == CoherenceMessageType:BISnpInvL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on bisnpfrom_in (addr: %#x)\n", st, LineAddress);
                  bisnpfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (getEntry(LineAddress).cacheL1.count() != 0) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1;
                  out_msg.Type := CoherenceMessageType:InvL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).ownerL1 := machineID;
                tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                getEntry(LineAddress).cacheL1.clear();
                if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                  getEntry(LineAddress).cacheL1.remove(machineID);
                  if (machineID == getEntry(LineAddress).ownerL1) {
                    getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                    enqueue(birspto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Control;
                      out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                      out_msg.Type := CoherenceMessageType:BIRspIL2;
                      out_msg.Sender := machineID;
                    }
                    setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                    trigger(Event:deallocbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  bisnpfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else {
              trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictI__C__E_evict) {
            if (in_msg.Type == CoherenceMessageType:BISnpDataL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__E_evict);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:BISnpInvL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__E_evict);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictI__C__E_evict_x_I) {
            if (in_msg.Type == CoherenceMessageType:BISnpDataL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__E_evict_x_I);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:BISnpInvL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__E_evict_x_I);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictI__C__M_evict) {
            if (in_msg.Type == CoherenceMessageType:BISnpDataL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__M_evict);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:BISnpInvL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__M_evict);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictI__C__S_evict) {
            if (in_msg.Type == CoherenceMessageType:BISnpDataL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__S_evict);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:BISnpInvL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__S_evict);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictI__C__S_evict_x_I) {
            if (in_msg.Type == CoherenceMessageType:BISnpDataL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__S_evict_x_I);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:BISnpInvL2) {
              enqueue(rwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:BIConflictL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__S_evict_x_I);
              DPRINTF(RubySlicc, "Popping %s %s on bisnpfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              bisnpfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else {
            trigger(Event:Stallbisnpfrom_in, LineAddress, getEntry(LineAddress), tbe);
          }
        }
      }
    }
    
    in_port(birspfrom_in, CoherenceMessage, birspFrom, rank=6) {
      if (birspfrom_in.isReady(clockEdge())) {
        peek (birspfrom_in, CoherenceMessage, block_on="LineAddress") {
          Addr LineAddress := in_msg.LineAddress;
          TBE tbe := TBEs[LineAddress];
          State st := getState(tbe, getEntry(LineAddress), LineAddress);
          DPRINTF(RubySlicc, "birspfrom_in: %s %s %s (addr: %#x)\n", in_msg.Type, in_msg.Sender, st, LineAddress);
          error("Invalid transition");
        }
      }
    }
    
    in_port(rwdfrom_in, CoherenceMessage, rwdFrom, rank=7) {
      if (rwdfrom_in.isReady(clockEdge())) {
        peek (rwdfrom_in, CoherenceMessage, block_on="LineAddress") {
          Addr LineAddress := in_msg.LineAddress;
          TBE tbe := TBEs[LineAddress];
          State st := getState(tbe, getEntry(LineAddress), LineAddress);
          DPRINTF(RubySlicc, "rwdfrom_in: %s %s %s (addr: %#x)\n", in_msg.Type, in_msg.Sender, st, LineAddress);
          error("Invalid transition");
        }
      }
    }

    in_port(req2from_in, CoherenceMessage, req2From, rank=8) {
      if (req2from_in.isReady(clockEdge())) {
        peek (req2from_in, CoherenceMessage, block_on="LineAddress") {
          Addr LineAddress := in_msg.LineAddress;
          TBE tbe := TBEs[LineAddress];
          State st := getState(tbe, getEntry(LineAddress), LineAddress);
          DPRINTF(RubySlicc, "req2from_in: %s %s %s (addr: %#x)\n", in_msg.Type, in_msg.Sender, st, LineAddress);
          error("Invalid transition");
        }
      }
    }
    
    //Backend.SLICC.ModularSLICC.proxy.GenProxyActions
    action(allocEntry, "a", desc="Allocate an entry") {
      assert(is_invalid(cache_entry));
      assert(cache.cacheAvail(address));
      set_cache_entry(cache.allocate(address, new Entry));
    }
    action(deallocEntry, "d", desc="Deallocate an entry") {
      assert(is_valid(cache_entry));
      cache.deallocate(address);
      unset_cache_entry();
    }
    action(a_allocTBE, "aTBE", desc="Allocate TBE entry.") {
      TBEs.allocate(address);
      set_tbe(TBEs[address]);
    }
    action(a_deallocTBE, "dTBE", desc="Deallocate TBE entry.") {
      if (is_valid(tbe)) {
        TBEs.deallocate(address);
        unset_tbe();
      }
    }
    action(a_copyEntryToTBE, "cpTBE", desc="Copy Entry to TBE.") {
      if (is_valid(cache_entry)) {
        if (is_valid(tbe)) {
          tbe.cl := cache_entry.cl;
          tbe.dirty := true;
        }
      }
    }
    action(popbirspfrom_in, "pbirspfrom_in0", desc="Pop the birspfrom_in queue.") {
      // Sometimes we need to be able to pop a queue/in_port from within a transition
      // rather than from within the in_port itself. Thus, we need an action for this,
      // since transitions cannot execute non-action functions.
      birspfrom_in.dequeue(clockEdge());
    }
    
    action(recyclebirspfrom_in, "rbirspfrom_in0", desc="Recycle the birspfrom_in port") {
      DPRINTF(RubySlicc, "Stalling birspfrom_in (addr: %#x)\n", address);
      birspfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
      //stall_and_wait(birspfrom_in, address);
    }
    
    action(popbisnpfrom_in, "pbisnpfrom_in0", desc="Pop the bisnpfrom_in queue.") {
      // Sometimes we need to be able to pop a queue/in_port from within a transition
      // rather than from within the in_port itself. Thus, we need an action for this,
      // since transitions cannot execute non-action functions.
      bisnpfrom_in.dequeue(clockEdge());
    }
    
    action(recyclebisnpfrom_in, "rbisnpfrom_in0", desc="Recycle the bisnpfrom_in port") {
      DPRINTF(RubySlicc, "Stalling bisnpfrom_in (addr: %#x)\n", address);
      bisnpfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
      //stall_and_wait(bisnpfrom_in, address);
    }
    
    action(popdrsfrom_in, "pdrsfrom_in0", desc="Pop the drsfrom_in queue.") {
      // Sometimes we need to be able to pop a queue/in_port from within a transition
      // rather than from within the in_port itself. Thus, we need an action for this,
      // since transitions cannot execute non-action functions.
      drsfrom_in.dequeue(clockEdge());
    }
    
    action(recycledrsfrom_in, "rdrsfrom_in0", desc="Recycle the drsfrom_in port") {
      DPRINTF(RubySlicc, "Stalling drsfrom_in (addr: %#x)\n", address);
      drsfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
      //stall_and_wait(drsfrom_in, address);
    }
    
    action(popfwdfrom_in, "pfwdfrom_in0", desc="Pop the fwdfrom_in queue.") {
      // Sometimes we need to be able to pop a queue/in_port from within a transition
      // rather than from within the in_port itself. Thus, we need an action for this,
      // since transitions cannot execute non-action functions.
      fwdfrom_in.dequeue(clockEdge());
    }
    
    action(recyclefwdfrom_in, "rfwdfrom_in0", desc="Recycle the fwdfrom_in port") {
      DPRINTF(RubySlicc, "Stalling fwdfrom_in (addr: %#x)\n", address);
      fwdfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
      //stall_and_wait(fwdfrom_in, address);
    }
    
    action(popndrfrom_in, "pndrfrom_in0", desc="Pop the ndrfrom_in queue.") {
      // Sometimes we need to be able to pop a queue/in_port from within a transition
      // rather than from within the in_port itself. Thus, we need an action for this,
      // since transitions cannot execute non-action functions.
      ndrfrom_in.dequeue(clockEdge());
    }
    
    action(recyclendrfrom_in, "rndrfrom_in0", desc="Recycle the ndrfrom_in port") {
      DPRINTF(RubySlicc, "Stalling ndrfrom_in (addr: %#x)\n", address);
      ndrfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
      //stall_and_wait(ndrfrom_in, address);
    }
    
    action(popreq2from_in, "preq2from_in0", desc="Pop the req2from_in queue.") {
      // Sometimes we need to be able to pop a queue/in_port from within a transition
      // rather than from within the in_port itself. Thus, we need an action for this,
      // since transitions cannot execute non-action functions.
      req2from_in.dequeue(clockEdge());
    }
    
    action(recyclereq2from_in, "rreq2from_in0", desc="Recycle the req2from_in port") {
      DPRINTF(RubySlicc, "Stalling req2from_in (addr: %#x)\n", address);
      req2from_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
      //stall_and_wait(req2from_in, address);
    }
    
    action(popreqfrom_in, "preqfrom_in0", desc="Pop the reqfrom_in queue.") {
      // Sometimes we need to be able to pop a queue/in_port from within a transition
      // rather than from within the in_port itself. Thus, we need an action for this,
      // since transitions cannot execute non-action functions.
      reqfrom_in.dequeue(clockEdge());
    }
    
    action(recyclereqfrom_in, "rreqfrom_in0", desc="Recycle the reqfrom_in port") {
      DPRINTF(RubySlicc, "Stalling reqfrom_in (addr: %#x)\n", address);
      //reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
      stall_and_wait(reqfrom_in, address);
    }
    
    action(poprespfrom_in, "prespfrom_in0", desc="Pop the respfrom_in queue.") {
      // Sometimes we need to be able to pop a queue/in_port from within a transition
      // rather than from within the in_port itself. Thus, we need an action for this,
      // since transitions cannot execute non-action functions.
      respfrom_in.dequeue(clockEdge());
    }
    
    action(recyclerespfrom_in, "rrespfrom_in0", desc="Recycle the respfrom_in port") {
      DPRINTF(RubySlicc, "Stalling respfrom_in (addr: %#x)\n", address);
      respfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
      //stall_and_wait(respfrom_in, address);
    }
    
    action(poprwdfrom_in, "prwdfrom_in0", desc="Pop the rwdfrom_in queue.") {
      // Sometimes we need to be able to pop a queue/in_port from within a transition
      // rather than from within the in_port itself. Thus, we need an action for this,
      // since transitions cannot execute non-action functions.
      rwdfrom_in.dequeue(clockEdge());
    }
    
    action(recyclerwdfrom_in, "rrwdfrom_in0", desc="Recycle the rwdfrom_in port") {
      DPRINTF(RubySlicc, "Stalling rwdfrom_in (addr: %#x)\n", address);
      rwdfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
      //stall_and_wait(rwdfrom_in, address);
    }
    
    action(empty, "e", desc="Empty action") {
      // empty action; useful as SLICC requires valid transitions
      // to be non-empty, but the actions being invoked can still be empty
      // e.g. to simulate a z-stall
    }
    
    //Backend.SLICC.ModularSLICC.proxy.GenProxyTransitions
    transition({I__C__I}, deallocbirspfrom_in) {
      deallocEntry;
      a_deallocTBE;
      popbirspfrom_in;
    }
    
    transition({I__C__I}, deallocbisnpfrom_in) {
      deallocEntry;
      a_deallocTBE;
      popbisnpfrom_in;
    }
    
    transition({I__C__I}, deallocdrsfrom_in) {
      deallocEntry;
      a_deallocTBE;
      popdrsfrom_in;
    }
    
    transition({I__C__I}, deallocfwdfrom_in) {
      deallocEntry;
      a_deallocTBE;
      popfwdfrom_in;
    }
    
    transition({I__C__I}, deallocndrfrom_in) {
      deallocEntry;
      a_deallocTBE;
      popndrfrom_in;
    }
    
    transition({I__C__I}, deallocreq2from_in) {
      deallocEntry;
      a_deallocTBE;
      popreq2from_in;
    }
    
    transition({I__C__I}, deallocreqfrom_in) {
      deallocEntry;
      a_deallocTBE;
      popreqfrom_in;
    }
    
    transition({I__C__I}, deallocrespfrom_in) {
      deallocEntry;
      a_deallocTBE;
      poprespfrom_in;
    }
    
    transition({I__C__I}, deallocrwdfrom_in) {
      deallocEntry;
      a_deallocTBE;
      poprwdfrom_in;
    }

    transition({evictI__C__S_evict, evictI__C__E_evict, evictI__C__M_evict}, deallocevict) {
      a_copyEntryToTBE;
      deallocEntry;
    }
    
    transition({BIConflictAckL2I__C__M_BIConflictAck, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dF_GetM_x_pI_store__C__E, BIConflictAckL2dF_GetM_x_pI_store__C__M, BIConflictAckL2dF_GetM_x_pI_store__C__S, BIConflictAckL2dF_GetM_x_pM__C__E, BIConflictAckL2dF_GetM_x_pM__C__M, BIConflictAckL2dF_GetM_x_pM__C__S, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__I_store, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store__C__E, BIConflictAckL2dM_x_pI_store__C__M, BIConflictAckL2dM_x_pI_store__C__S, BISnpDataL2I__C__M_BISnpData, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dF_GetM_x_pI_store__C__E, BISnpDataL2dF_GetM_x_pI_store__C__M, BISnpDataL2dF_GetM_x_pI_store__C__S, BISnpDataL2dF_GetM_x_pM__C__E, BISnpDataL2dF_GetM_x_pM__C__M, BISnpDataL2dF_GetM_x_pM__C__S, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpDataL2dM_x_pI_store__C__E, BISnpDataL2dM_x_pI_store__C__M, BISnpDataL2dM_x_pI_store__C__S, BISnpInvL2I__C__M_BISnpInv, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dF_GetM_x_pI_store__C__E, BISnpInvL2dF_GetM_x_pI_store__C__M, BISnpInvL2dF_GetM_x_pI_store__C__S, BISnpInvL2dF_GetM_x_pM__C__E, BISnpInvL2dF_GetM_x_pM__C__M, BISnpInvL2dF_GetM_x_pM__C__S, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpInvL2dM_x_pI_store__C__E, BISnpInvL2dM_x_pI_store__C__M, BISnpInvL2dM_x_pI_store__C__S, E__C__M, F__C__E, F__C__M, F__C__S, GetML1F_GetM__C__M, GetML1F__C__I_store, GetML1F__C__I_store_Cmp_E, GetML1F__C__S_store, GetML1I__C__I_store, GetML1I__C__I_store_Cmp_E, GetML1I__C__S_store, GetML1S__C__I_store, GetML1S__C__I_store_Cmp_E, GetML1S__C__S_store, GetSL1E_GetS__C__M, GetSL1F_GetS__C__E, GetSL1F_GetS__C__M, GetSL1F_GetS__C__S, GetSL1I__C__I_store, GetSL1I__C__I_store_Cmp_E, GetSL1I__C__I_store_Cmp_S,GetSL1I__C__S_store, GetSL1M_GetS__C__M, I__C__E, I__C__I, I__C__M, I__C__S, M__C__M, S__C__E, S__C__M, S__C__S, evictI__C__E_evict, evictI__C__E_evict_x_I, evictI__C__M_evict, evictI__C__M_evict_BIConflictAck, evictI__C__S_evict, evictI__C__S_evict_x_I, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__E, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__M, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__S, evictdF_GetM_x_pI_store__C__E, evictdF_GetM_x_pI_store__C__M, evictdF_GetM_x_pI_store__C__S, evictdF_GetM_x_pM__C__E, evictdF_GetM_x_pM__C__M, evictdF_GetM_x_pM__C__S, evictdM_x_pI_store_GetF_Ack_AD__C__E, evictdM_x_pI_store_GetF_Ack_AD__C__M, evictdM_x_pI_store_GetF_Ack_AD__C__S, evictdM_x_pI_store_GetM_Ack_AD__C__E, evictdM_x_pI_store_GetM_Ack_AD__C__M, evictdM_x_pI_store_GetM_Ack_AD__C__S, evictdM_x_pI_store__C__E, evictdM_x_pI_store__C__M, evictdM_x_pI_store__C__S}, Stallbirspfrom_in) {
      recyclebirspfrom_in;
    }
    
    transition({BIConflictAckL2I__C__M_BIConflictAck, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dF_GetM_x_pI_store__C__E, BIConflictAckL2dF_GetM_x_pI_store__C__M, BIConflictAckL2dF_GetM_x_pI_store__C__S, BIConflictAckL2dF_GetM_x_pM__C__E, BIConflictAckL2dF_GetM_x_pM__C__M, BIConflictAckL2dF_GetM_x_pM__C__S, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__I_store, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store__C__E, BIConflictAckL2dM_x_pI_store__C__M, BIConflictAckL2dM_x_pI_store__C__S, BISnpDataL2I__C__M_BISnpData, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dF_GetM_x_pI_store__C__E, BISnpDataL2dF_GetM_x_pI_store__C__M, BISnpDataL2dF_GetM_x_pI_store__C__S, BISnpDataL2dF_GetM_x_pM__C__E, BISnpDataL2dF_GetM_x_pM__C__M, BISnpDataL2dF_GetM_x_pM__C__S, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpDataL2dM_x_pI_store__C__E, BISnpDataL2dM_x_pI_store__C__M, BISnpDataL2dM_x_pI_store__C__S, BISnpInvL2I__C__M_BISnpInv, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dF_GetM_x_pI_store__C__E, BISnpInvL2dF_GetM_x_pI_store__C__M, BISnpInvL2dF_GetM_x_pI_store__C__S, BISnpInvL2dF_GetM_x_pM__C__E, BISnpInvL2dF_GetM_x_pM__C__M, BISnpInvL2dF_GetM_x_pM__C__S, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpInvL2dM_x_pI_store__C__E, BISnpInvL2dM_x_pI_store__C__M, BISnpInvL2dM_x_pI_store__C__S, E__C__M, F__C__E, F__C__M, F__C__S, GetML1F_GetM__C__M, GetML1F__C__I_store, GetML1F__C__I_store_Cmp_E, GetML1F__C__S_store, GetML1I__C__I_store, GetML1I__C__I_store_Cmp_E, GetML1I__C__S_store, GetML1S__C__I_store, GetML1S__C__I_store_Cmp_E, GetML1S__C__S_store, GetSL1E_GetS__C__M, GetSL1F_GetS__C__E, GetSL1F_GetS__C__M, GetSL1F_GetS__C__S, GetSL1I__C__I_store, GetSL1I__C__I_store_Cmp_E, GetSL1I__C__I_store_Cmp_S,GetSL1I__C__S_store, GetSL1M_GetS__C__M, I__C__E, I__C__I, I__C__M, I__C__S, M__C__M, S__C__E, S__C__M, S__C__S, evictI__C__E_evict, evictI__C__E_evict_x_I, evictI__C__M_evict, evictI__C__M_evict_BIConflictAck, evictI__C__S_evict, evictI__C__S_evict_x_I, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__E, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__M, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__S, evictdF_GetM_x_pI_store__C__E, evictdF_GetM_x_pI_store__C__M, evictdF_GetM_x_pI_store__C__S, evictdF_GetM_x_pM__C__E, evictdF_GetM_x_pM__C__M, evictdF_GetM_x_pM__C__S, evictdM_x_pI_store_GetF_Ack_AD__C__E, evictdM_x_pI_store_GetF_Ack_AD__C__M, evictdM_x_pI_store_GetF_Ack_AD__C__S, evictdM_x_pI_store_GetM_Ack_AD__C__E, evictdM_x_pI_store_GetM_Ack_AD__C__M, evictdM_x_pI_store_GetM_Ack_AD__C__S, evictdM_x_pI_store__C__E, evictdM_x_pI_store__C__M, evictdM_x_pI_store__C__S}, Stallbisnpfrom_in) {
      recyclebisnpfrom_in;
    }
    
    transition({BIConflictAckL2I__C__M_BIConflictAck, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dF_GetM_x_pI_store__C__E, BIConflictAckL2dF_GetM_x_pI_store__C__M, BIConflictAckL2dF_GetM_x_pI_store__C__S, BIConflictAckL2dF_GetM_x_pM__C__E, BIConflictAckL2dF_GetM_x_pM__C__M, BIConflictAckL2dF_GetM_x_pM__C__S, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__I_store, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store__C__E, BIConflictAckL2dM_x_pI_store__C__M, BIConflictAckL2dM_x_pI_store__C__S, BISnpDataL2I__C__M_BISnpData, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dF_GetM_x_pI_store__C__E, BISnpDataL2dF_GetM_x_pI_store__C__M, BISnpDataL2dF_GetM_x_pI_store__C__S, BISnpDataL2dF_GetM_x_pM__C__E, BISnpDataL2dF_GetM_x_pM__C__M, BISnpDataL2dF_GetM_x_pM__C__S, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpDataL2dM_x_pI_store__C__E, BISnpDataL2dM_x_pI_store__C__M, BISnpDataL2dM_x_pI_store__C__S, BISnpInvL2I__C__M_BISnpInv, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dF_GetM_x_pI_store__C__E, BISnpInvL2dF_GetM_x_pI_store__C__M, BISnpInvL2dF_GetM_x_pI_store__C__S, BISnpInvL2dF_GetM_x_pM__C__E, BISnpInvL2dF_GetM_x_pM__C__M, BISnpInvL2dF_GetM_x_pM__C__S, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpInvL2dM_x_pI_store__C__E, BISnpInvL2dM_x_pI_store__C__M, BISnpInvL2dM_x_pI_store__C__S, E__C__M, F__C__E, F__C__M, F__C__S, GetML1F_GetM__C__M, GetML1F__C__I_store, GetML1F__C__I_store_Cmp_E, GetML1F__C__S_store, GetML1I__C__I_store, GetML1I__C__I_store_Cmp_E, GetML1I__C__S_store, GetML1S__C__I_store, GetML1S__C__I_store_Cmp_E, GetML1S__C__S_store, GetSL1E_GetS__C__M, GetSL1F_GetS__C__E, GetSL1F_GetS__C__M, GetSL1F_GetS__C__S, GetSL1I__C__I_store, GetSL1I__C__I_store_Cmp_E, GetSL1I__C__I_store_Cmp_S,GetSL1I__C__S_store, GetSL1M_GetS__C__M, I__C__E, I__C__I, I__C__M, I__C__S, M__C__M, S__C__E, S__C__M, S__C__S, evictI__C__E_evict, evictI__C__E_evict_x_I, evictI__C__M_evict, evictI__C__M_evict_BIConflictAck, evictI__C__S_evict, evictI__C__S_evict_x_I, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__E, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__M, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__S, evictdF_GetM_x_pI_store__C__E, evictdF_GetM_x_pI_store__C__M, evictdF_GetM_x_pI_store__C__S, evictdF_GetM_x_pM__C__E, evictdF_GetM_x_pM__C__M, evictdF_GetM_x_pM__C__S, evictdM_x_pI_store_GetF_Ack_AD__C__E, evictdM_x_pI_store_GetF_Ack_AD__C__M, evictdM_x_pI_store_GetF_Ack_AD__C__S, evictdM_x_pI_store_GetM_Ack_AD__C__E, evictdM_x_pI_store_GetM_Ack_AD__C__M, evictdM_x_pI_store_GetM_Ack_AD__C__S, evictdM_x_pI_store__C__E, evictdM_x_pI_store__C__M, evictdM_x_pI_store__C__S}, Stalldrsfrom_in) {
      recycledrsfrom_in;
    }
    
    transition({BIConflictAckL2I__C__M_BIConflictAck, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dF_GetM_x_pI_store__C__E, BIConflictAckL2dF_GetM_x_pI_store__C__M, BIConflictAckL2dF_GetM_x_pI_store__C__S, BIConflictAckL2dF_GetM_x_pM__C__E, BIConflictAckL2dF_GetM_x_pM__C__M, BIConflictAckL2dF_GetM_x_pM__C__S, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__I_store, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store__C__E, BIConflictAckL2dM_x_pI_store__C__M, BIConflictAckL2dM_x_pI_store__C__S, BISnpDataL2I__C__M_BISnpData, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dF_GetM_x_pI_store__C__E, BISnpDataL2dF_GetM_x_pI_store__C__M, BISnpDataL2dF_GetM_x_pI_store__C__S, BISnpDataL2dF_GetM_x_pM__C__E, BISnpDataL2dF_GetM_x_pM__C__M, BISnpDataL2dF_GetM_x_pM__C__S, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpDataL2dM_x_pI_store__C__E, BISnpDataL2dM_x_pI_store__C__M, BISnpDataL2dM_x_pI_store__C__S, BISnpInvL2I__C__M_BISnpInv, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dF_GetM_x_pI_store__C__E, BISnpInvL2dF_GetM_x_pI_store__C__M, BISnpInvL2dF_GetM_x_pI_store__C__S, BISnpInvL2dF_GetM_x_pM__C__E, BISnpInvL2dF_GetM_x_pM__C__M, BISnpInvL2dF_GetM_x_pM__C__S, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpInvL2dM_x_pI_store__C__E, BISnpInvL2dM_x_pI_store__C__M, BISnpInvL2dM_x_pI_store__C__S, E__C__M, F__C__E, F__C__M, F__C__S, GetML1F_GetM__C__M, GetML1F__C__I_store, GetML1F__C__I_store_Cmp_E, GetML1F__C__S_store, GetML1I__C__I_store, GetML1I__C__I_store_Cmp_E, GetML1I__C__S_store, GetML1S__C__I_store, GetML1S__C__I_store_Cmp_E, GetML1S__C__S_store, GetSL1E_GetS__C__M, GetSL1F_GetS__C__E, GetSL1F_GetS__C__M, GetSL1F_GetS__C__S, GetSL1I__C__I_store, GetSL1I__C__I_store_Cmp_E, GetSL1I__C__I_store_Cmp_S,GetSL1I__C__S_store, GetSL1M_GetS__C__M, I__C__E, I__C__I, I__C__M, I__C__S, M__C__M, S__C__E, S__C__M, S__C__S, evictI__C__E_evict, evictI__C__E_evict_x_I, evictI__C__M_evict, evictI__C__M_evict_BIConflictAck, evictI__C__S_evict, evictI__C__S_evict_x_I, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__E, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__M, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__S, evictdF_GetM_x_pI_store__C__E, evictdF_GetM_x_pI_store__C__M, evictdF_GetM_x_pI_store__C__S, evictdF_GetM_x_pM__C__E, evictdF_GetM_x_pM__C__M, evictdF_GetM_x_pM__C__S, evictdM_x_pI_store_GetF_Ack_AD__C__E, evictdM_x_pI_store_GetF_Ack_AD__C__M, evictdM_x_pI_store_GetF_Ack_AD__C__S, evictdM_x_pI_store_GetM_Ack_AD__C__E, evictdM_x_pI_store_GetM_Ack_AD__C__M, evictdM_x_pI_store_GetM_Ack_AD__C__S, evictdM_x_pI_store__C__E, evictdM_x_pI_store__C__M, evictdM_x_pI_store__C__S}, Stallfwdfrom_in) {
      recyclefwdfrom_in;
    }
    
    transition({BIConflictAckL2I__C__M_BIConflictAck, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dF_GetM_x_pI_store__C__E, BIConflictAckL2dF_GetM_x_pI_store__C__M, BIConflictAckL2dF_GetM_x_pI_store__C__S, BIConflictAckL2dF_GetM_x_pM__C__E, BIConflictAckL2dF_GetM_x_pM__C__M, BIConflictAckL2dF_GetM_x_pM__C__S, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__I_store, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store__C__E, BIConflictAckL2dM_x_pI_store__C__M, BIConflictAckL2dM_x_pI_store__C__S, BISnpDataL2I__C__M_BISnpData, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dF_GetM_x_pI_store__C__E, BISnpDataL2dF_GetM_x_pI_store__C__M, BISnpDataL2dF_GetM_x_pI_store__C__S, BISnpDataL2dF_GetM_x_pM__C__E, BISnpDataL2dF_GetM_x_pM__C__M, BISnpDataL2dF_GetM_x_pM__C__S, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpDataL2dM_x_pI_store__C__E, BISnpDataL2dM_x_pI_store__C__M, BISnpDataL2dM_x_pI_store__C__S, BISnpInvL2I__C__M_BISnpInv, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dF_GetM_x_pI_store__C__E, BISnpInvL2dF_GetM_x_pI_store__C__M, BISnpInvL2dF_GetM_x_pI_store__C__S, BISnpInvL2dF_GetM_x_pM__C__E, BISnpInvL2dF_GetM_x_pM__C__M, BISnpInvL2dF_GetM_x_pM__C__S, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpInvL2dM_x_pI_store__C__E, BISnpInvL2dM_x_pI_store__C__M, BISnpInvL2dM_x_pI_store__C__S, E__C__M, F__C__E, F__C__M, F__C__S, GetML1F_GetM__C__M, GetML1F__C__I_store, GetML1F__C__I_store_Cmp_E, GetML1F__C__S_store, GetML1I__C__I_store, GetML1I__C__I_store_Cmp_E, GetML1I__C__S_store, GetML1S__C__I_store, GetML1S__C__I_store_Cmp_E, GetML1S__C__S_store, GetSL1E_GetS__C__M, GetSL1F_GetS__C__E, GetSL1F_GetS__C__M, GetSL1F_GetS__C__S, GetSL1I__C__I_store, GetSL1I__C__I_store_Cmp_E, GetSL1I__C__I_store_Cmp_S,GetSL1I__C__S_store, GetSL1M_GetS__C__M, I__C__E, I__C__I, I__C__M, I__C__S, M__C__M, S__C__E, S__C__M, S__C__S, evictI__C__E_evict, evictI__C__E_evict_x_I, evictI__C__M_evict, evictI__C__M_evict_BIConflictAck, evictI__C__S_evict, evictI__C__S_evict_x_I, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__E, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__M, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__S, evictdF_GetM_x_pI_store__C__E, evictdF_GetM_x_pI_store__C__M, evictdF_GetM_x_pI_store__C__S, evictdF_GetM_x_pM__C__E, evictdF_GetM_x_pM__C__M, evictdF_GetM_x_pM__C__S, evictdM_x_pI_store_GetF_Ack_AD__C__E, evictdM_x_pI_store_GetF_Ack_AD__C__M, evictdM_x_pI_store_GetF_Ack_AD__C__S, evictdM_x_pI_store_GetM_Ack_AD__C__E, evictdM_x_pI_store_GetM_Ack_AD__C__M, evictdM_x_pI_store_GetM_Ack_AD__C__S, evictdM_x_pI_store__C__E, evictdM_x_pI_store__C__M, evictdM_x_pI_store__C__S}, Stallndrfrom_in) {
      recyclendrfrom_in;
    }
    
    transition({BIConflictAckL2I__C__M_BIConflictAck, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dF_GetM_x_pI_store__C__E, BIConflictAckL2dF_GetM_x_pI_store__C__M, BIConflictAckL2dF_GetM_x_pI_store__C__S, BIConflictAckL2dF_GetM_x_pM__C__E, BIConflictAckL2dF_GetM_x_pM__C__M, BIConflictAckL2dF_GetM_x_pM__C__S, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__I_store, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store__C__E, BIConflictAckL2dM_x_pI_store__C__M, BIConflictAckL2dM_x_pI_store__C__S, BISnpDataL2I__C__M_BISnpData, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dF_GetM_x_pI_store__C__E, BISnpDataL2dF_GetM_x_pI_store__C__M, BISnpDataL2dF_GetM_x_pI_store__C__S, BISnpDataL2dF_GetM_x_pM__C__E, BISnpDataL2dF_GetM_x_pM__C__M, BISnpDataL2dF_GetM_x_pM__C__S, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpDataL2dM_x_pI_store__C__E, BISnpDataL2dM_x_pI_store__C__M, BISnpDataL2dM_x_pI_store__C__S, BISnpInvL2I__C__M_BISnpInv, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dF_GetM_x_pI_store__C__E, BISnpInvL2dF_GetM_x_pI_store__C__M, BISnpInvL2dF_GetM_x_pI_store__C__S, BISnpInvL2dF_GetM_x_pM__C__E, BISnpInvL2dF_GetM_x_pM__C__M, BISnpInvL2dF_GetM_x_pM__C__S, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpInvL2dM_x_pI_store__C__E, BISnpInvL2dM_x_pI_store__C__M, BISnpInvL2dM_x_pI_store__C__S, E__C__M, F__C__E, F__C__M, F__C__S, GetML1F_GetM__C__M, GetML1F__C__I_store, GetML1F__C__I_store_Cmp_E, GetML1F__C__S_store, GetML1I__C__I_store, GetML1I__C__I_store_Cmp_E, GetML1I__C__S_store, GetML1S__C__I_store, GetML1S__C__I_store_Cmp_E, GetML1S__C__S_store, GetSL1E_GetS__C__M, GetSL1F_GetS__C__E, GetSL1F_GetS__C__M, GetSL1F_GetS__C__S, GetSL1I__C__I_store, GetSL1I__C__I_store_Cmp_E, GetSL1I__C__I_store_Cmp_S,GetSL1I__C__S_store, GetSL1M_GetS__C__M, I__C__E, I__C__I, I__C__M, I__C__S, M__C__M, S__C__E, S__C__M, S__C__S, evictI__C__E_evict, evictI__C__E_evict_x_I, evictI__C__M_evict, evictI__C__M_evict_BIConflictAck, evictI__C__S_evict, evictI__C__S_evict_x_I, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__E, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__M, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__S, evictdF_GetM_x_pI_store__C__E, evictdF_GetM_x_pI_store__C__M, evictdF_GetM_x_pI_store__C__S, evictdF_GetM_x_pM__C__E, evictdF_GetM_x_pM__C__M, evictdF_GetM_x_pM__C__S, evictdM_x_pI_store_GetF_Ack_AD__C__E, evictdM_x_pI_store_GetF_Ack_AD__C__M, evictdM_x_pI_store_GetF_Ack_AD__C__S, evictdM_x_pI_store_GetM_Ack_AD__C__E, evictdM_x_pI_store_GetM_Ack_AD__C__M, evictdM_x_pI_store_GetM_Ack_AD__C__S, evictdM_x_pI_store__C__E, evictdM_x_pI_store__C__M, evictdM_x_pI_store__C__S}, Stallreq2from_in) {
      recyclereq2from_in;
    }
    
    transition({BIConflictAckL2I__C__M_BIConflictAck, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dF_GetM_x_pI_store__C__E, BIConflictAckL2dF_GetM_x_pI_store__C__M, BIConflictAckL2dF_GetM_x_pI_store__C__S, BIConflictAckL2dF_GetM_x_pM__C__E, BIConflictAckL2dF_GetM_x_pM__C__M, BIConflictAckL2dF_GetM_x_pM__C__S, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__I_store, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store__C__E, BIConflictAckL2dM_x_pI_store__C__M, BIConflictAckL2dM_x_pI_store__C__S, BISnpDataL2I__C__M_BISnpData, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dF_GetM_x_pI_store__C__E, BISnpDataL2dF_GetM_x_pI_store__C__M, BISnpDataL2dF_GetM_x_pI_store__C__S, BISnpDataL2dF_GetM_x_pM__C__E, BISnpDataL2dF_GetM_x_pM__C__M, BISnpDataL2dF_GetM_x_pM__C__S, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpDataL2dM_x_pI_store__C__E, BISnpDataL2dM_x_pI_store__C__M, BISnpDataL2dM_x_pI_store__C__S, BISnpInvL2I__C__M_BISnpInv, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dF_GetM_x_pI_store__C__E, BISnpInvL2dF_GetM_x_pI_store__C__M, BISnpInvL2dF_GetM_x_pI_store__C__S, BISnpInvL2dF_GetM_x_pM__C__E, BISnpInvL2dF_GetM_x_pM__C__M, BISnpInvL2dF_GetM_x_pM__C__S, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpInvL2dM_x_pI_store__C__E, BISnpInvL2dM_x_pI_store__C__M, BISnpInvL2dM_x_pI_store__C__S, E__C__M, F__C__E, F__C__M, F__C__S, GetML1F_GetM__C__M, GetML1F__C__I_store, GetML1F__C__I_store_Cmp_E, GetML1F__C__S_store, GetML1I__C__I_store, GetML1I__C__I_store_Cmp_E, GetML1I__C__S_store, GetML1S__C__I_store, GetML1S__C__I_store_Cmp_E, GetML1S__C__S_store, GetSL1E_GetS__C__M, GetSL1F_GetS__C__E, GetSL1F_GetS__C__M, GetSL1F_GetS__C__S, GetSL1I__C__I_store, GetSL1I__C__I_store_Cmp_E, GetSL1I__C__I_store_Cmp_S,GetSL1I__C__S_store, GetSL1M_GetS__C__M, I__C__E, I__C__I, I__C__M, I__C__S, M__C__M, S__C__E, S__C__M, S__C__S, evictI__C__E_evict, evictI__C__E_evict_x_I, evictI__C__M_evict, evictI__C__M_evict_BIConflictAck, evictI__C__S_evict, evictI__C__S_evict_x_I, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__E, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__M, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__S, evictdF_GetM_x_pI_store__C__E, evictdF_GetM_x_pI_store__C__M, evictdF_GetM_x_pI_store__C__S, evictdF_GetM_x_pM__C__E, evictdF_GetM_x_pM__C__M, evictdF_GetM_x_pM__C__S, evictdM_x_pI_store_GetF_Ack_AD__C__E, evictdM_x_pI_store_GetF_Ack_AD__C__M, evictdM_x_pI_store_GetF_Ack_AD__C__S, evictdM_x_pI_store_GetM_Ack_AD__C__E, evictdM_x_pI_store_GetM_Ack_AD__C__M, evictdM_x_pI_store_GetM_Ack_AD__C__S, evictdM_x_pI_store__C__E, evictdM_x_pI_store__C__M, evictdM_x_pI_store__C__S}, Stallreqfrom_in) {
      recyclereqfrom_in;
    }
    
    transition({BIConflictAckL2I__C__M_BIConflictAck, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dF_GetM_x_pI_store__C__E, BIConflictAckL2dF_GetM_x_pI_store__C__M, BIConflictAckL2dF_GetM_x_pI_store__C__S, BIConflictAckL2dF_GetM_x_pM__C__E, BIConflictAckL2dF_GetM_x_pM__C__M, BIConflictAckL2dF_GetM_x_pM__C__S, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__I_store, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store__C__E, BIConflictAckL2dM_x_pI_store__C__M, BIConflictAckL2dM_x_pI_store__C__S, BISnpDataL2I__C__M_BISnpData, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dF_GetM_x_pI_store__C__E, BISnpDataL2dF_GetM_x_pI_store__C__M, BISnpDataL2dF_GetM_x_pI_store__C__S, BISnpDataL2dF_GetM_x_pM__C__E, BISnpDataL2dF_GetM_x_pM__C__M, BISnpDataL2dF_GetM_x_pM__C__S, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpDataL2dM_x_pI_store__C__E, BISnpDataL2dM_x_pI_store__C__M, BISnpDataL2dM_x_pI_store__C__S, BISnpInvL2I__C__M_BISnpInv, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dF_GetM_x_pI_store__C__E, BISnpInvL2dF_GetM_x_pI_store__C__M, BISnpInvL2dF_GetM_x_pI_store__C__S, BISnpInvL2dF_GetM_x_pM__C__E, BISnpInvL2dF_GetM_x_pM__C__M, BISnpInvL2dF_GetM_x_pM__C__S, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpInvL2dM_x_pI_store__C__E, BISnpInvL2dM_x_pI_store__C__M, BISnpInvL2dM_x_pI_store__C__S, E__C__M, F__C__E, F__C__M, F__C__S, GetML1F_GetM__C__M, GetML1F__C__I_store, GetML1F__C__I_store_Cmp_E, GetML1F__C__S_store, GetML1I__C__I_store, GetML1I__C__I_store_Cmp_E, GetML1I__C__S_store, GetML1S__C__I_store, GetML1S__C__I_store_Cmp_E, GetML1S__C__S_store, GetSL1E_GetS__C__M, GetSL1F_GetS__C__E, GetSL1F_GetS__C__M, GetSL1F_GetS__C__S, GetSL1I__C__I_store, GetSL1I__C__I_store_Cmp_E, GetSL1I__C__I_store_Cmp_S,GetSL1I__C__S_store, GetSL1M_GetS__C__M, I__C__E, I__C__I, I__C__M, I__C__S, M__C__M, S__C__E, S__C__M, S__C__S, evictI__C__E_evict, evictI__C__E_evict_x_I, evictI__C__M_evict, evictI__C__M_evict_BIConflictAck, evictI__C__S_evict, evictI__C__S_evict_x_I, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__E, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__M, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__S, evictdF_GetM_x_pI_store__C__E, evictdF_GetM_x_pI_store__C__M, evictdF_GetM_x_pI_store__C__S, evictdF_GetM_x_pM__C__E, evictdF_GetM_x_pM__C__M, evictdF_GetM_x_pM__C__S, evictdM_x_pI_store_GetF_Ack_AD__C__E, evictdM_x_pI_store_GetF_Ack_AD__C__M, evictdM_x_pI_store_GetF_Ack_AD__C__S, evictdM_x_pI_store_GetM_Ack_AD__C__E, evictdM_x_pI_store_GetM_Ack_AD__C__M, evictdM_x_pI_store_GetM_Ack_AD__C__S, evictdM_x_pI_store__C__E, evictdM_x_pI_store__C__M, evictdM_x_pI_store__C__S}, Stallrespfrom_in) {
      recyclerespfrom_in;
    }
    
    transition({BIConflictAckL2I__C__M_BIConflictAck, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dF_GetM_x_pI_store__C__E, BIConflictAckL2dF_GetM_x_pI_store__C__M, BIConflictAckL2dF_GetM_x_pI_store__C__S, BIConflictAckL2dF_GetM_x_pM__C__E, BIConflictAckL2dF_GetM_x_pM__C__M, BIConflictAckL2dF_GetM_x_pM__C__S, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__I_store, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store__C__E, BIConflictAckL2dM_x_pI_store__C__M, BIConflictAckL2dM_x_pI_store__C__S, BISnpDataL2I__C__M_BISnpData, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dF_GetM_x_pI_store__C__E, BISnpDataL2dF_GetM_x_pI_store__C__M, BISnpDataL2dF_GetM_x_pI_store__C__S, BISnpDataL2dF_GetM_x_pM__C__E, BISnpDataL2dF_GetM_x_pM__C__M, BISnpDataL2dF_GetM_x_pM__C__S, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpDataL2dM_x_pI_store__C__E, BISnpDataL2dM_x_pI_store__C__M, BISnpDataL2dM_x_pI_store__C__S, BISnpInvL2I__C__M_BISnpInv, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dF_GetM_x_pI_store__C__E, BISnpInvL2dF_GetM_x_pI_store__C__M, BISnpInvL2dF_GetM_x_pI_store__C__S, BISnpInvL2dF_GetM_x_pM__C__E, BISnpInvL2dF_GetM_x_pM__C__M, BISnpInvL2dF_GetM_x_pM__C__S, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpInvL2dM_x_pI_store__C__E, BISnpInvL2dM_x_pI_store__C__M, BISnpInvL2dM_x_pI_store__C__S, E__C__M, F__C__E, F__C__M, F__C__S, GetML1F_GetM__C__M, GetML1F__C__I_store, GetML1F__C__I_store_Cmp_E, GetML1F__C__S_store, GetML1I__C__I_store, GetML1I__C__I_store_Cmp_E, GetML1I__C__S_store, GetML1S__C__I_store, GetML1S__C__I_store_Cmp_E, GetML1S__C__S_store, GetSL1E_GetS__C__M, GetSL1F_GetS__C__E, GetSL1F_GetS__C__M, GetSL1F_GetS__C__S, GetSL1I__C__I_store, GetSL1I__C__I_store_Cmp_E, GetSL1I__C__I_store_Cmp_S,GetSL1I__C__S_store, GetSL1M_GetS__C__M, I__C__E, I__C__I, I__C__M, I__C__S, M__C__M, S__C__E, S__C__M, S__C__S, evictI__C__E_evict, evictI__C__E_evict_x_I, evictI__C__M_evict, evictI__C__M_evict_BIConflictAck, evictI__C__S_evict, evictI__C__S_evict_x_I, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__E, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__M, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__S, evictdF_GetM_x_pI_store__C__E, evictdF_GetM_x_pI_store__C__M, evictdF_GetM_x_pI_store__C__S, evictdF_GetM_x_pM__C__E, evictdF_GetM_x_pM__C__M, evictdF_GetM_x_pM__C__S, evictdM_x_pI_store_GetF_Ack_AD__C__E, evictdM_x_pI_store_GetF_Ack_AD__C__M, evictdM_x_pI_store_GetF_Ack_AD__C__S, evictdM_x_pI_store_GetM_Ack_AD__C__E, evictdM_x_pI_store_GetM_Ack_AD__C__M, evictdM_x_pI_store_GetM_Ack_AD__C__S, evictdM_x_pI_store__C__E, evictdM_x_pI_store__C__M, evictdM_x_pI_store__C__S}, Stallrwdfrom_in) {
      recyclerwdfrom_in;
    }
    
    transition({BIConflictAckL2I__C__M_BIConflictAck, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dF_GetM_x_pI_store__C__E, BIConflictAckL2dF_GetM_x_pI_store__C__M, BIConflictAckL2dF_GetM_x_pI_store__C__S, BIConflictAckL2dF_GetM_x_pM__C__E, BIConflictAckL2dF_GetM_x_pM__C__M, BIConflictAckL2dF_GetM_x_pM__C__S, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__I_store, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store__C__E, BIConflictAckL2dM_x_pI_store__C__M, BIConflictAckL2dM_x_pI_store__C__S, BISnpDataL2I__C__M_BISnpData, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dF_GetM_x_pI_store__C__E, BISnpDataL2dF_GetM_x_pI_store__C__M, BISnpDataL2dF_GetM_x_pI_store__C__S, BISnpDataL2dF_GetM_x_pM__C__E, BISnpDataL2dF_GetM_x_pM__C__M, BISnpDataL2dF_GetM_x_pM__C__S, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpDataL2dM_x_pI_store__C__E, BISnpDataL2dM_x_pI_store__C__M, BISnpDataL2dM_x_pI_store__C__S, BISnpInvL2I__C__M_BISnpInv, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dF_GetM_x_pI_store__C__E, BISnpInvL2dF_GetM_x_pI_store__C__M, BISnpInvL2dF_GetM_x_pI_store__C__S, BISnpInvL2dF_GetM_x_pM__C__E, BISnpInvL2dF_GetM_x_pM__C__M, BISnpInvL2dF_GetM_x_pM__C__S, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpInvL2dM_x_pI_store__C__E, BISnpInvL2dM_x_pI_store__C__M, BISnpInvL2dM_x_pI_store__C__S, E__C__M, F__C__E, F__C__M, F__C__S, GetML1F_GetM__C__M, GetML1F__C__I_store, GetML1F__C__I_store_Cmp_E, GetML1F__C__S_store, GetML1I__C__I_store, GetML1I__C__I_store_Cmp_E, GetML1I__C__S_store, GetML1S__C__I_store, GetML1S__C__I_store_Cmp_E, GetML1S__C__S_store, GetSL1E_GetS__C__M, GetSL1F_GetS__C__E, GetSL1F_GetS__C__M, GetSL1F_GetS__C__S, GetSL1I__C__I_store, GetSL1I__C__I_store_Cmp_E, GetSL1I__C__I_store_Cmp_S,GetSL1I__C__S_store, GetSL1M_GetS__C__M, I__C__E, I__C__I, I__C__M, I__C__S, M__C__M, S__C__E, S__C__M, S__C__S, evictI__C__E_evict, evictI__C__E_evict_x_I, evictI__C__M_evict, evictI__C__M_evict_BIConflictAck, evictI__C__S_evict, evictI__C__S_evict_x_I, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__E, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__M, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__S, evictdF_GetM_x_pI_store__C__E, evictdF_GetM_x_pI_store__C__M, evictdF_GetM_x_pI_store__C__S, evictdF_GetM_x_pM__C__E, evictdF_GetM_x_pM__C__M, evictdF_GetM_x_pM__C__S, evictdM_x_pI_store_GetF_Ack_AD__C__E, evictdM_x_pI_store_GetF_Ack_AD__C__M, evictdM_x_pI_store_GetF_Ack_AD__C__S, evictdM_x_pI_store_GetM_Ack_AD__C__E, evictdM_x_pI_store_GetM_Ack_AD__C__M, evictdM_x_pI_store_GetM_Ack_AD__C__S, evictdM_x_pI_store__C__E, evictdM_x_pI_store__C__M, evictdM_x_pI_store__C__S}, allocCacheEntry) {
      allocEntry;
    }
    
    transition({BIConflictAckL2I__C__M_BIConflictAck, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dF_GetM_x_pI_store__C__E, BIConflictAckL2dF_GetM_x_pI_store__C__M, BIConflictAckL2dF_GetM_x_pI_store__C__S, BIConflictAckL2dF_GetM_x_pM__C__E, BIConflictAckL2dF_GetM_x_pM__C__M, BIConflictAckL2dF_GetM_x_pM__C__S, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__I_store, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store__C__E, BIConflictAckL2dM_x_pI_store__C__M, BIConflictAckL2dM_x_pI_store__C__S, BISnpDataL2I__C__M_BISnpData, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dF_GetM_x_pI_store__C__E, BISnpDataL2dF_GetM_x_pI_store__C__M, BISnpDataL2dF_GetM_x_pI_store__C__S, BISnpDataL2dF_GetM_x_pM__C__E, BISnpDataL2dF_GetM_x_pM__C__M, BISnpDataL2dF_GetM_x_pM__C__S, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpDataL2dM_x_pI_store__C__E, BISnpDataL2dM_x_pI_store__C__M, BISnpDataL2dM_x_pI_store__C__S, BISnpInvL2I__C__M_BISnpInv, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dF_GetM_x_pI_store__C__E, BISnpInvL2dF_GetM_x_pI_store__C__M, BISnpInvL2dF_GetM_x_pI_store__C__S, BISnpInvL2dF_GetM_x_pM__C__E, BISnpInvL2dF_GetM_x_pM__C__M, BISnpInvL2dF_GetM_x_pM__C__S, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpInvL2dM_x_pI_store__C__E, BISnpInvL2dM_x_pI_store__C__M, BISnpInvL2dM_x_pI_store__C__S, E__C__M, F__C__E, F__C__M, F__C__S, GetML1F_GetM__C__M, GetML1F__C__I_store, GetML1F__C__I_store_Cmp_E, GetML1F__C__S_store, GetML1I__C__I_store, GetML1I__C__I_store_Cmp_E, GetML1I__C__S_store, GetML1S__C__I_store, GetML1S__C__I_store_Cmp_E, GetML1S__C__S_store, GetSL1E_GetS__C__M, GetSL1F_GetS__C__E, GetSL1F_GetS__C__M, GetSL1F_GetS__C__S, GetSL1I__C__I_store, GetSL1I__C__I_store_Cmp_E,GetSL1I__C__I_store_Cmp_S, GetSL1I__C__S_store, GetSL1M_GetS__C__M, I__C__E, I__C__I, I__C__M, I__C__S, M__C__M, S__C__E, S__C__M, S__C__S, evictI__C__E_evict, evictI__C__E_evict_x_I, evictI__C__M_evict, evictI__C__M_evict_BIConflictAck, evictI__C__S_evict, evictI__C__S_evict_x_I, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__E, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__M, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__S, evictdF_GetM_x_pI_store__C__E, evictdF_GetM_x_pI_store__C__M, evictdF_GetM_x_pI_store__C__S, evictdF_GetM_x_pM__C__E, evictdF_GetM_x_pM__C__M, evictdF_GetM_x_pM__C__S, evictdM_x_pI_store_GetF_Ack_AD__C__E, evictdM_x_pI_store_GetF_Ack_AD__C__M, evictdM_x_pI_store_GetF_Ack_AD__C__S, evictdM_x_pI_store_GetM_Ack_AD__C__E, evictdM_x_pI_store_GetM_Ack_AD__C__M, evictdM_x_pI_store_GetM_Ack_AD__C__S, evictdM_x_pI_store__C__E, evictdM_x_pI_store__C__M, evictdM_x_pI_store__C__S}, allocTBE) {
      a_allocTBE;
    }
    
    transition({BIConflictAckL2I__C__M_BIConflictAck, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dF_GetM_x_pI_store__C__E, BIConflictAckL2dF_GetM_x_pI_store__C__M, BIConflictAckL2dF_GetM_x_pI_store__C__S, BIConflictAckL2dF_GetM_x_pM__C__E, BIConflictAckL2dF_GetM_x_pM__C__M, BIConflictAckL2dF_GetM_x_pM__C__S, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__I_store, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store__C__E, BIConflictAckL2dM_x_pI_store__C__M, BIConflictAckL2dM_x_pI_store__C__S, BISnpDataL2I__C__M_BISnpData, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dF_GetM_x_pI_store__C__E, BISnpDataL2dF_GetM_x_pI_store__C__M, BISnpDataL2dF_GetM_x_pI_store__C__S, BISnpDataL2dF_GetM_x_pM__C__E, BISnpDataL2dF_GetM_x_pM__C__M, BISnpDataL2dF_GetM_x_pM__C__S, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpDataL2dM_x_pI_store__C__E, BISnpDataL2dM_x_pI_store__C__M, BISnpDataL2dM_x_pI_store__C__S, BISnpInvL2I__C__M_BISnpInv, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dF_GetM_x_pI_store__C__E, BISnpInvL2dF_GetM_x_pI_store__C__M, BISnpInvL2dF_GetM_x_pI_store__C__S, BISnpInvL2dF_GetM_x_pM__C__E, BISnpInvL2dF_GetM_x_pM__C__M, BISnpInvL2dF_GetM_x_pM__C__S, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpInvL2dM_x_pI_store__C__E, BISnpInvL2dM_x_pI_store__C__M, BISnpInvL2dM_x_pI_store__C__S, E__C__M, F__C__E, F__C__M, F__C__S, GetML1F_GetM__C__M, GetML1F__C__I_store, GetML1F__C__I_store_Cmp_E, GetML1F__C__S_store, GetML1I__C__I_store, GetML1I__C__I_store_Cmp_E, GetML1I__C__S_store, GetML1S__C__I_store, GetML1S__C__I_store_Cmp_E, GetML1S__C__S_store, GetSL1E_GetS__C__M, GetSL1F_GetS__C__E, GetSL1F_GetS__C__M, GetSL1F_GetS__C__S, GetSL1I__C__I_store, GetSL1I__C__I_store_Cmp_E, GetSL1I__C__I_store_Cmp_S,GetSL1I__C__S_store, GetSL1M_GetS__C__M, I__C__E, I__C__I, I__C__M, I__C__S, M__C__M, S__C__E, S__C__M, S__C__S, evictI__C__E_evict, evictI__C__E_evict_x_I, evictI__C__M_evict, evictI__C__M_evict_BIConflictAck, evictI__C__S_evict, evictI__C__S_evict_x_I, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__E, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__M, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__S, evictdF_GetM_x_pI_store__C__E, evictdF_GetM_x_pI_store__C__M, evictdF_GetM_x_pI_store__C__S, evictdF_GetM_x_pM__C__E, evictdF_GetM_x_pM__C__M, evictdF_GetM_x_pM__C__S, evictdM_x_pI_store_GetF_Ack_AD__C__E, evictdM_x_pI_store_GetF_Ack_AD__C__M, evictdM_x_pI_store_GetF_Ack_AD__C__S, evictdM_x_pI_store_GetM_Ack_AD__C__E, evictdM_x_pI_store_GetM_Ack_AD__C__M, evictdM_x_pI_store_GetM_Ack_AD__C__S, evictdM_x_pI_store__C__E, evictdM_x_pI_store__C__M, evictdM_x_pI_store__C__S}, deallocTBE) {
      a_deallocTBE;
    }
    
    transition({BIConflictAckL2I__C__M_BIConflictAck, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dF_GetM_x_pI_store__C__E, BIConflictAckL2dF_GetM_x_pI_store__C__M, BIConflictAckL2dF_GetM_x_pI_store__C__S, BIConflictAckL2dF_GetM_x_pM__C__E, BIConflictAckL2dF_GetM_x_pM__C__M, BIConflictAckL2dF_GetM_x_pM__C__S, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetF_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__E, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__I_store, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__M, BIConflictAckL2dM_x_pI_store_GetM_Ack_AD__C__S, BIConflictAckL2dM_x_pI_store__C__E, BIConflictAckL2dM_x_pI_store__C__M, BIConflictAckL2dM_x_pI_store__C__S, BISnpDataL2I__C__M_BISnpData, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dF_GetM_x_pI_store__C__E, BISnpDataL2dF_GetM_x_pI_store__C__M, BISnpDataL2dF_GetM_x_pI_store__C__S, BISnpDataL2dF_GetM_x_pM__C__E, BISnpDataL2dF_GetM_x_pM__C__M, BISnpDataL2dF_GetM_x_pM__C__S, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpDataL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpDataL2dM_x_pI_store__C__E, BISnpDataL2dM_x_pI_store__C__M, BISnpDataL2dM_x_pI_store__C__S, BISnpInvL2I__C__M_BISnpInv, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dF_GetM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dF_GetM_x_pI_store__C__E, BISnpInvL2dF_GetM_x_pI_store__C__M, BISnpInvL2dF_GetM_x_pI_store__C__S, BISnpInvL2dF_GetM_x_pM__C__E, BISnpInvL2dF_GetM_x_pM__C__M, BISnpInvL2dF_GetM_x_pM__C__S, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetF_Ack_AD__C__S, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__E, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__M, BISnpInvL2dM_x_pI_store_GetM_Ack_AD__C__S, BISnpInvL2dM_x_pI_store__C__E, BISnpInvL2dM_x_pI_store__C__M, BISnpInvL2dM_x_pI_store__C__S, E__C__M, F__C__E, F__C__M, F__C__S, GetML1F_GetM__C__M, GetML1F__C__I_store, GetML1F__C__I_store_Cmp_E, GetML1F__C__S_store, GetML1I__C__I_store, GetML1I__C__I_store_Cmp_E, GetML1I__C__S_store, GetML1S__C__I_store, GetML1S__C__I_store_Cmp_E, GetML1S__C__S_store, GetSL1E_GetS__C__M, GetSL1F_GetS__C__E, GetSL1F_GetS__C__M, GetSL1F_GetS__C__S, GetSL1I__C__I_store, GetSL1I__C__I_store_Cmp_E, GetSL1I__C__I_store_Cmp_S, GetSL1I__C__S_store, GetSL1M_GetS__C__M, I__C__E, I__C__I, I__C__M, I__C__S, M__C__M, S__C__E, S__C__M, S__C__S, evictI__C__E_evict, evictI__C__E_evict_x_I, evictI__C__M_evict, evictI__C__M_evict_BIConflictAck, evictI__C__S_evict, evictI__C__S_evict_x_I, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__E, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__M, evictdF_GetM_x_pI_store_GetF_Ack_AD__C__S, evictdF_GetM_x_pI_store__C__E, evictdF_GetM_x_pI_store__C__M, evictdF_GetM_x_pI_store__C__S, evictdF_GetM_x_pM__C__E, evictdF_GetM_x_pM__C__M, evictdF_GetM_x_pM__C__S, evictdM_x_pI_store_GetF_Ack_AD__C__E, evictdM_x_pI_store_GetF_Ack_AD__C__M, evictdM_x_pI_store_GetF_Ack_AD__C__S, evictdM_x_pI_store_GetM_Ack_AD__C__E, evictdM_x_pI_store_GetM_Ack_AD__C__M, evictdM_x_pI_store_GetM_Ack_AD__C__S, evictdM_x_pI_store__C__E, evictdM_x_pI_store__C__M, evictdM_x_pI_store__C__S}, Progress) {
      empty;
    }
}
// EOF<proxy>
